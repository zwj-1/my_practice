## 1.Lock和synchronized的区别和使用

#### **1.1 synchronized实现原理**

synchronized是基于Monitor来实现同步的。

Monitor从两个方面来支持线程之间的同步：

- 互斥执行
- 协作

1、Java 使用对象锁 ( 使用 synchronized 获得对象锁 ) 保证工作在共享的数据集上的线程互斥执行。

2、使用 notify/notifyAll/wait 方法来协同不同线程之间的工作。

3、Class和Object都关联了一个Monitor。



![img](https:////upload-images.jianshu.io/upload_images/15535205-2a427bed8559b1b5?imageMogr2/auto-orient/strip%7CimageView2/2/w/500/format/webp)

image

Monitor 的工作机理

- 线程进入同步方法中。
- 为了继续执行临界区代码，线程必须获取 Monitor 锁。如果获取锁成功，将成为该监视者对象的拥有者。任一时刻内，监视者对象只属于一个活动线程（The Owner）
- 拥有监视者对象的线程可以调用 wait() 进入等待集合（Wait Set），同时释放监视锁，进入等待状态。
- 其他线程调用 notify() / notifyAll() 接口唤醒等待集合中的线程，这些等待的线程需要重新获取监视锁后才能执行 wait() 之后的代码。
- 同步方法执行完毕了，线程退出临界区，并释放监视锁

#### 1.1.1. synchronized的实现原理

使用monitorenter和monitorexit指令实现的：

- monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处
- 每个monitorenter必须有对应的monitorexit与之配对
- 任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态

一.synchronized的缺陷

​		1）Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个接口，通过这个类可以实现同步访问；

　	　2）Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。

　　二.java.util.concurrent.locks包下常用的类

​		1.Lock接口中的方法：lock()、tryLock()、tryLock(long time, TimeUnit unit)和lockInterruptibly()是用来获取锁的。unLock()方法是用来释放锁的。

​			lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。

​			tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。

​			tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。

​			lockInterruptibly()方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态，，当一个线程获取了锁之后，是不会被interrupt()方法中断的，如果没有获取到锁，且进入了等待状态，泽调用interrupt()方法可以进行中断等待		

​		2.ReentrantLock，意思是可重入锁，ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法。

​		3.ReadWriteLock，也是一个接口，在它里面只定义了两个方法：readLock()和writeLock()

​		4.ReentrantReadWriteLock，里面提供了很多丰富的方法，不过最主要的有两个方法：readLock()和writeLock()用来获取读锁和写锁。

​		总的来说：

​		1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；

　	　2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；

　	　3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；

　　	4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。

　　	5）Lock可以提高多个线程进行读操作的效率。

​	【选择规则】在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。

#### 　1.2.java锁的种类

1、自旋锁 ,自旋，jvm默认是10次吧，有jvm自己控制。for去争取锁

2、阻塞锁 被阻塞的线程，不会争夺锁。

3、可重入锁： 多次进入改锁的域         Lock和synchronized都是可重入锁

​		加锁时，需要判断锁是否已经被获取。如果已经被获取，则判断获取锁的线程是否是当前线程。如果是当前线程，则给获取次数加1。如果不是当前线程，则需要等待。

​		释放锁时，需要给锁的获取次数减1，然后判断，次数是否为0了。如果次数为0了，则需要调用锁的唤醒方法，让锁上阻塞的其他线程得到执行的机会。

4、读写锁：

​		ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。可以通过readLock()获取读锁，通过writeLock()获取写锁。

​		当同时获取读锁的时候就会同时执行，当只要有一个写锁时，另外的锁就会进入等待状态

5、互斥锁 锁本身就是互斥的

6、悲观锁 不相信，这里会是安全的，必须全部上锁

7、乐观锁 相信，这里是安全的。（CAS就是一种乐观锁技术）

8、公平锁 ：有优先级的锁   公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。

​			synchronized是非公平锁

​			ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。`可以通过这样来设置为公平锁ReentrantLock lock = new` `ReentrantLock(true);`

9、非公平锁 无优先级的锁

10、偏向锁 无竞争不锁，有竞争挂起，转为轻量锁

11、对象锁 锁住对象

12、线程锁

13、锁粗化 多锁变成一个，自己处理

14、轻量级锁 CAS 实现

15、锁消除 偏向锁就是锁消除的一种

16、锁膨胀 jvm实现，锁粗化

17、信号量 使用阻塞锁 实现的一种策略

18、排它锁：X锁，若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A。



![偏向锁轻量级锁重量级锁](D:\BaiduYunDownload\面试题信息\面试题中的图片\偏向锁轻量级锁重量级锁.png)

​			

## 2.线程的三大特性

​	原子性：是指一个操作是不可中断的。即使是多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。

　　　	　比如，对于一个静态全局变量int i，两个线程同时对它赋值，线程A给他赋值为1，线程B给他赋值为-1。那么不管这两个线程

　　　　	以何种方式。何种步调工作，i的值要么是1，要么是-1.线程A和线程B之间是没有干扰的。这就是原子性的一个特点，不可被中断。

​	可见性：是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改。显然，对于串行来说，可见性问题是不存在的。

​	有序性：在并发时，程序的执行可能会出现乱序。给人的直观感觉就是：写在前面的代码，会在后面执行。有序性问题的原因是因为程序在

　　　　	执行时，可能会进行指令重排，重排后的指令与原指令的顺序未必一致。

## 3.volatile实现原理

#### 	3.1volatile两大作用

​		1、保证内存可见性：通过happen-before原则保证内存可见性

​		2、防止指令重排

​		此外需注意volatile**并不保证操作的原子性。**

#### （一）内存可见性

##### 1 概念[JMM模型]

**JVM内存模型：主内存和线程独立的工作内存**

Java内存模型规定，对于多个线程共享的变量，存储在主内存当中，每个线程都有自己独立的工作内存（比如CPU的寄存器），线程只能访问自己的工作内存，不可以访问其它线程的工作内存。

工作内存中保存了主内存共享变量的**副本**，线程要操作这些共享变量，只能通过操作工作内存中的副本来实现，操作完毕之后再同步回到主内存当中。

如何保证多个线程操作主内存的数据完整性是一个难题，Java内存模型也规定了【工作内存与主内存之间交互的协议】，定义了8种原子操作：

(1) lock:将主内存中的变量锁定，为一个线程所独占

(2) unclock:将lock加的锁定解除，此时其它的线程可以有机会访问此变量

(3) read:将主内存中的变量值读到工作内存当中

(4) load:将read读取的值保存到工作内存中的变量副本中。

(5) use:将值传递给线程的代码执行引擎

(6) assign:将执行引擎处理返回的值重新赋值给变量副本

(7) store:将变量副本的值存储到主内存中。

(8) write:将store存储的值写入到主内存的共享变量当中。

**通过上面Java内存模型的概述，我们会注意到这么一个问题，每个线程在获取锁之后会在自己的工作内存来操作共享变量，操作完成之后将工作内存中的副本回写到主内存，并且在其它线程从主内存将变量同步回自己的工作内存之前，共享变量的改变对其是不可见的。**

##### 2 内存可见性带来的问题

​	很多时候我们需要一个线程对共享变量的改动，其它线程也需要立即得知这个改动该怎么办呢？

##### 3 提供内存可见性

volatile保证可见性的原理是在**每次访问变量时都会进行一次刷新**，因此每次访问都是主内存中最新的版本。所以volatile关键字的作用之一就是**保证变量修改的实时可见性**。

#### （二）指令重排

##### 1 概念

指令重排序是JVM为了优化指令，提高程序运行效率，在不影响单线程程序执行结果的前提下，尽可能地提高并行度。编译器、处理器也遵循这样一个目标。

##### 2 指令重排带来的问题

如果一个操作不是原子的，就会给JVM留下重排的机会。

##### 3 防止指令重排

除了前面内存可见性中讲到的volatile关键字可以保证变量修改的可见性之外，还有另一个重要的作用：**在JDK1.5之后，可以使用volatile变量禁止指令重排序。**

volatile关键字通过提供“**内存屏障**”的方式来防止指令被重排序，为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。

#### （三）总结

##### volatile是轻量级同步机制

相对于synchronized块的代码锁，volatile应该是提供了一个轻量级的针对共享变量的锁，当我们在多个线程间使用共享变量进行通信的时候需要考虑将共享变量用volatile来修饰。

volatile是一种稍弱的同步机制，在访问volatile变量时不会执行加锁操作，也就不会执行线程阻塞，因此volatilei变量是一种比synchronized关键字更轻量级的同步机制。

##### volatile使用建议

使用建议：在两个或者更多的线程需要访问的成员变量上使用volatile。当要访问的变量已在synchronized代码块中，或者为常量时，没必要使用volatile。

由于使用volatile屏蔽掉了JVM中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。

##### volatile和synchronized区别

​	**1、volatile不会进行加锁操作：**

​	volatile变量是一种稍弱的同步机制在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比synchronized关键字更轻量级的同步机制。

​	**2、volatile变量作用类似于同步变量读写操作：**

​	从内存可见性的角度看，写入volatile变量相当于退出同步代码块，而读取volatile变量相当于进入同步代码块。

​	**3、volatile不如synchronized安全：**

​		在代码中如果过度依赖volatile变量来控制状态的可见性，通常会比使用锁的代码更脆弱，也更难以理解。仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它。一般来说，用同步机制会更安全些。

​	4、**volatile无法同时保证内存可见性和原子性：**

​	加锁机制（即同步机制）既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性，原因是声明为volatile的简单变量如果当前值与该变量以前的值相关，那么volatile关键字不起作用，也就是说如下的表达式都不是原子操作：“count++”、“count = count+1”。

​	**当且仅当满足以下所有条件时，才应该使用volatile变量：**

​	1、 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。

​	2、该变量没有包含在具有其他变量的不变式中。

总结：在需要同步的时候，第一选择应该是synchronized关键字，这是最安全的方式，尝试其他任何方式都是有风险的。尤其在、jdK1.5之后，对synchronized同步机制做了很多优化，如：自适应的自旋锁、锁粗化、锁消除、轻量级锁等，使得它的性能明显有了很大的提升。



## 4.死锁的产生条件、解决方法

​	1.**死锁：**指多个进程因竞争共享资源而造成的一种僵局，若无外力作用，这些进程都将永远不能再 向前推进。

​	2.**产生死锁的原因：**（1）竞争系统资源 （2）进程的推进顺序不当

​	3.. 产生死锁的四个必要条件？

​		（1）互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源

​		（2）请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放

​		（3）不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放

​		（4）环路等待条件：是指进程发生死锁后，必然存在一个进程--资源之间的环形链

​	4.处理死锁的基本方法

​		1.预防死锁：通过设置一些限制条件，去破坏产生死锁的必要条件

​		2.避免死锁：在资源分配过程中，使用某种方法避免系统进入不安全的状态，从而避免发生死锁

​		3.检测死锁：允许死锁的发生，但是通过系统的检测之后，采取一些措施，将死锁清除掉

​		4.解除死锁：该方法与检测死锁配合使用

## 5.ThreadLocal的了解，实现原理。

​	ThreadLocal称为线程本地变量，其为变量在每个线程中都创建了一个副本，每个线程都访问和修改本线程中变量的副本。

首先，ThreadLocal 不是用来解决共享对象的多线程访问问题的，一般情况下，通过ThreadLocal.set() 到线程中的对象是该线程自己使用的对象，其他线程是不需要访问的，也访问不到的。**各个线程中访问的是不同的对象。

1.ThreadLocal的实现原理:

​	 ThreadLocal的内部实现，主要关注的就是set()和get()方法。

​	**Thread****类内部有一个实例变量：

​		**ThreadLocal.ThreadLocalMap threadLocals = null;**	threadLocals 变量就是存储set（）进去的值，可以通过get（）方法获取

​	同时，threadLocals 变量只存在于当前线程，这样就不存在多线程的并发问题了！！！

2.**ThreadLocal**使用场景：

​	最常见的ThreadLocal使用场景为用来解决数据库连接、Session管理等。

## 6.AQS和Condition 

#### 1.AQS(`AbstractQueuedSynchronizer`)，

​	AQS是JDK下提供的一套用于实现基于FIFO等待队列的阻塞锁和相关的同步器的一个同步框架。它使用了一个原子的int value status来作为同步器的状态（如：独占锁，1代表已占有，0代表未占有），通过该类提供的原子修改status方法（getState setState and compareAnsSetState），我们可以把它作为同步器的基础框架类来实现各种同步器。AQS还定义了一个实现了Condition接口的ConditionObject内部类。Condition 将 Object 监视器方法（wait、notify 和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 set （wait-set）。其中，Lock 替代了 synchronized 方法和语句的使用，Condition 替代了 Object 监视器方法的使用。

#### 2.Condition 

​	Condition提供类似于Object的wait、notify的功能signal和await，都是可以使一个正在执行的线程挂起（推迟执行），直到被其他线程唤醒。但是Condition更加强大，如支持多个条件谓词、保证线程唤醒的顺序和在挂起时不需要拥有锁。这个抽象类被设计为作为一些可用原子int值来表示状态的同步器的基类。

## 7.创建线程的几种方式？

Java使用Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。创建线程的方式如下4种：

​	1.**继承Thread类创建线程**  ```MyThread extends Thread{}   new MyThread().start();//创建并启动线程```

​	2.**实现Runnable接口创建线程**  ``` MyThread2 implements Runnable {}  new Thread(new MyThread2()).start();```  

​	3.**使用Callable和Future创建线程** 

​		和Runnable接口不一样，Callable接口提供了一个call方法作为线程执行体，call()方法比run()方法功能要强大,可以有返回值和声明异常抛出.

​		V get()：返回Callable里call方法的返回值，调用这个方法会导致程序阻塞，必须等到子线程结束后才会得到返回值

​		V get(long timeout,TimeUnit unit)：返回Callable里call方法的返回值，最多阻塞timeout时间，经过指定时间没有返回抛出TimeoutException

​		boolean isDone()：若Callable任务完成，返回True

​		boolean isCancelled()：如果在Callable任务正常完成前被取消，返回True

​	4.**使用线程池**

​		**Executor接口**  的最大优点是把任务的提交和执行 **解耦**。要执行任务的人只需把Task描述清楚，然后提交即可。这个Task是怎么被执行的，被谁执行的，什么时候执行的，提交的人就不用关心了. 

​	创建线程池的四种方式：

​	1、newFixedThreadPool创建一个固定长度的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，线程池的规模将不再变化。如果某个线程由于发生了未预期的异常而结束，那么线程池将会补充一个新的线程。 
​	2、newCachedThreadPool创建一个可缓存的线程池。这种类型的线程池特点是： 
1).工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。 
2).如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。 
​	3、newSingleThreadExecutor创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，如果这个线程异常结束，会有另一个取代它，保证顺序执行(我觉得这点是它的特色)。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的 。

​	4、newScheduleThreadPool创建一个定长的线程池，而且支持定时的以及周期性的任务执行，类似于Timer。 【可以给定一个延迟的时间，程序会在等待这个时间后执行线程里面的代码】

【注意】 Callable 和 Runnable接口的区别

1.   （1）Callable规定的方法是call()，而Runnable规定的方法是run(). 
2.   （2）Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。  
3.   （3）call()方法可抛出异常，而run()方法是不能抛出异常的。 
4.   （4）运行Callable任务可拿到一个Future对象， Future表示异步计算的结果。 
5.   它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。 
6.   通过Future对象可了解任务执行情况，可取消任务的执行，还可获取任务执行的结果。 
7. Callable是类似于Runnable的接口，实现Callable接口的类和实现Runnable的类都是可被其它线程执行的任务。 

## 8. java内存区域与内存溢出异常

#### 	1.程序计数器(线程私有)

​			

 &概念与存储：一块较小的内存空间，看做是当前线程所执行的字节码的行号指示器。       【 记录的是偏移地址】

​			程序计数器的功能相当于PC寄存器的功能，如果当前执行的是Java方法，则指示当前字节码指令的地址，如果执行的是本地方法，则值为Undefined。

                 &特性： 线程私有的内存。
    
                            因为java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，任意时刻，一个处理器都智慧执行一个线程中的指令，所以每个线程都需要有一个独立的程序计数器。
    
                  &异常：没有规定任何OutOfMemeoryError情况的区域。
#### 	2.java虚拟机栈（线程私有）

			& 概念与存储：描述java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈，动态链接，方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
	
	                                其中，64位长度的long和double类型的数据会占用2个局部变量空间，其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，空间是完全确定的，在方法运行期不会改变局部变量表的大小。
	
	             &特性：线程私有，生命周期与线程相同。
	
	             &异常： 
	
	                       stackOverflowError:线程请求栈深度大于虚拟机所允许的深度。
	
	                       OutOfMemeoryError:扩展时无法申请到足够内存。
#### 	3.java堆（线程共享）

 		&概念于存储：是java虚拟机所管理的内存中最大的一块。在虚拟机启动时创建。唯一目的就是存放对象实例。 堆用于存储对象实例，java中通new创建的对象实例就保存在堆中.

                  &特性：线程共享的一块区域。
    
                  &其他：java堆是垃圾收集器管理的主要区域，也被称为GC堆。从内存回收的角度来看，现在收集器基本采用分代收集算法，所以：
    
                   &分类：新生代、老年代。或者（Eden空间，From Survivor空间，To Survivor空间等）。
                   
                   &异常： 
    
                           OutOfMemeoryError:扩展时无法申请到足够内存。

#### 	4.本地方法栈（线程私有）

​			与虚拟机栈作用相似，区别就是虚拟机栈为虚拟机执行java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。Sun HotSpot将两者合并。

#### 	5.方法区(线程共享)

​		&概念与存储：存储已经被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。

                                   java虚拟机规范把方法区描述为堆的一个逻辑部分，但她还有一个别名叫Non-Heap（非堆），目的是与java堆区分开。很多人愿意把方法区称为永久代。
    
              &特性：线程共享
              【常量池】：分类静态常量池和动态常量池：
              静态常量池，在编译后产生，
              动态常量池，在运行期间产生，里面包括静态常量池的所有内容，同时将静态常量池里面的符号引用转换为直接引用
​		jdk1.8之前，字符串常量池就位于方法区。

​		jdk1.8之后，字符串常量池就移动到了堆中。【永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。元空间 的本质和永久代类似，元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用 本地内存。

​				因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 native  memory, 字符串池和类的静态变量放入 java 堆中，这样可以加载多少类的元数据就不再由 MaxPermSize 控制, 而由系统的实际可用空间来控制。】

​	 &异常： 当方法区无法满足内存分配要求时，将抛出OutOfMemoryError异常。

## 9.垃圾回收机制-->1

​	jvm会在什么时候进行回收 : 

​		1.会在cpu空闲的时候自动进行回收

​		2.在堆内存存储满了之后

​		3.主动调用System.gc()后尝试进行回收

**可达性分析法**（java应用的算法）也叫做：根搜索算法【这个是jvm的搜索算法】

​	这个算法的基本思想是通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链（即GC Roots到对象不可达）时，则证明此对象是不可用的。

那么问题又来了，如何选取GCRoots对象呢？在Java语言中，可以作为GCRoots的对象包括下面几种：

​		(1). 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。

​		(2). 方法区中的类静态属性引用的对象。

​		(3). 方法区中常量引用的对象。

​		(4). 本地方法栈中JNI(Native方法)引用的对象。

**引用计数法**（其他很多语言在用，但是java没有应用这个算法）

​	这个算法的实现是，给对象中添加一个引用计数器，每当一个地方引用这个对象时，计数器值+1；当引用失效时，计数器值-1。任何时刻计数值为0的对象就是不可能再被使用的。这种算法使用场景很多，但是，Java中却没有使用这种算法，因为这种算法很难解决对象之间相互引用的情况

**方法区的垃圾回收**

​	方法区的垃圾回收主要回收两部分内容：1. 废弃常量。2. 无用的类。

​	如何判断废弃常量呢？以字面量回收为例，

​		如果一个字符串“abc”已经进入常量池，但是当前系统没有任何一个String对象引用了叫做“abc”的字面量，那么，如果发生垃圾回收并且有必要时，“abc”就会被系统移出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。

​	如何判断无用的类呢？需要满足以下三个条件

​		1.该类的所有实例都已经被回收，即Java堆中不存在该类的任何实例。

​		2. 加载该类的ClassLoader已经被回收。

​		3.该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

**垃圾收集算法**【这个是jvm对于搜索到无用对象后采用的垃圾回收算法】（这里主要就是堆内存里面的回收）

​		新生代：主要是用来存放新生的对象。一般占据堆的1/3空间。

​		老年代：主要存放应用程序中生命周期长的内存对象。

​	**1、标记-清除（Mark-Sweep）算法**

​		分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。

​	**特点**：（1）效率问题，标记和清除的效率都不高；（2）空间的问题，标记清除以后会产生大量不连续的空间碎片，空间碎片太多可能会导致程序运行过程需要分配较大的对象时候，无法找到足够连续内存而不得不提前触发一次垃圾收集。

​	**2、复制（Copying）算法**

​		**它将可用的内存分为两块，每次只用其中一块，当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次性清理掉**。

​	**特点**：没有内存碎片，只要移动堆顶指针，按顺序分配内存即可。代价是将内存缩小位原来的一半。

​	**3、标记-整理（Mark-Compact）算法**

​		让所有存活对象都向一端移动，然后直接清理掉边界以外的内存

​	**特点**：不会产生空间碎片，但是整理会花一定的时间。

​	**4、分代收集算法**

​		大批对象死去、少量对象存活的（新生代），使用复制算法，复制成本低；对象存活率高、没有额外空间进行分配担保的（老年代），采用标记-清理算法或者标记-整理算法。

**垃圾收集器**

重点笔记：

- 并行（Parallel）：多条垃圾收集线程

- 并发（Concurrent）：用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户线程在继续运行，而垃圾收集程序运行于另外一个CPU上。

- 新生代：Serial收集器　　ParNew收集器　　Parallel Scavenge收集器

- 老年代：Serial Old收集器　　Parallel Old收集器　　CMS收集器

- 整堆收集器：G1收集器

  

​	**1.Serial收集器:**    (采用复制算法的单线程的收集器)-->**是虚拟机运行在Client模式下的默认新生代收集器**  串行收集器 和Serial Old收集器配合

​	**2.ParNew收集器**:  (ParNew收集器其实就是Serial收集器的多线程版本) -->**它是Server模式下的虚拟机首选的新生代收集器**   和CMS配合使用

​	**3、Parallel Scavenge收集器**  (也是一个新生代收集器，也是用复制算法的收集器，也是并行的多线程收集器)-->**是虚拟机运行在Server模式下的默认垃圾收集器**   吞吐量收集器     和Parallel Old收集器  配合使用

​	**4、Serial Old收集器**   (**Serial收集器的老年代版本，同样是一个单线程收集器，****使用“标记-整理算法**)-->是在于给Client模式下的虚拟机使用。

​	**5、Parallel Old收集器**   (**Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法**)-->是虚拟机运行在Server模式下的默认垃圾收集器        

​	**6、CMS收集器**   (**是以获取最短回收停顿时间为目标的收集器。使用标记 - 清除算法**)          低停顿收集器

​	**7、G1收集器**   (它将整个Java堆划分为多个大小相等的独立区域（Region）   )          单独使用

CMS收集器：

​	垃圾回收过程： 	

​	（A）、初始标记（CMS initial mark）：	仅标记一下GC Roots能直接关联到的对象；  速度很快； 但需要"Stop The World"；

​	（B）、并发标记（CMS concurrent mark）： 进行GC Roots Tracing的过程；刚才产生的集合中标记出存活对象；         

​										   应用程序也在运行；并不能保证可以标记出所有的存活对象；

​	（C）、重新标记（CMS remark）：为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录； 

​								需要"Stop The World"，且停顿时间比初始标记稍长，但远比并发标记短； 采用多线程并行执行来提升效率；

​	（D）、并发清除（CMS concurrent sweep）：    回收所有的垃圾对象；

​	CMS收集器的3个缺点：

​		（A）、对CPU资源非常敏感

​		（B）、无法处理浮动垃圾,可能出现"Concurrent Mode Failure"失败

​		（C）、产生大量内存碎片 （标记清楚算法：  产生大量不连续的内存碎片会导致分配大内存对象时，无法找到足够的连续内存，从而需要提前触发另一次Full GC动作）

G1收集器：

​	优势：

​		（1）、超过50％的Java堆被活动数据占用；

​      	（2）、对象分配频率或年代提升频率变化很大；

​     	 （3）、GC停顿时间过长（长于0.5至1秒）。

​	垃圾回收过程：

​		（A）、初始标记（Initial Marking）：仅标记一下GC Roots能直接关联到的对象；且修改TAMS（Next Top at Mark Start）,让下一阶段并发运行时，用户程序能在正确可用的Region中创建新对象；

   									需要"Stop The World"，但速度很快；

​		（B）、并发标记（Concurrent Marking）：进行GC Roots Tracing的过程； 刚才产生的集合中标记出存活对象；

   										   耗时较长，但应用程序也在运行；并不能保证可以标记出所有的存活对象；

​		（C）、最终标记（Final Marking）：为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录；上一阶段对象的变化记录在线程的Remembered Set Log； 这里把Remembered Set Log合并到Remembered Set中；

​                   							 需要"Stop The World"，且停顿时间比初始标记稍长，但远比并发标记短； 采用多线程并行执行来提升效率；

​		（D）、筛选回收（Live Data Counting and Evacuation）： 首先排序各个Region的回收价值和成本；然后根据用户期望的GC停顿时间来制定回收计划； 最后按计划回收一些价值高的Region中垃圾对象；             

   													   回收时采用"复制"算法，从一个或多个Region复制存活对象到堆上的另一个空的Region，并且在此过程中压缩和释放内存；

​														可以并发进行，降低停顿时间，并增加吞吐量；

## 10.内存分配与回收策略-->2(垃圾回收机制的补充)

重点笔记：

新生代GC（Minor GC）：发生在新生代的垃圾收集动作，非常频繁，一般回收速度也比较快。【占据堆内存的1/3的区域】【Eden区占据8/10，from区占据1/10，to占据1/10】

老年代GC（Major GC/Full GC）：发生在老年代的垃圾收集动作，一般会伴随Major  GC 速度一般比Minor GC慢上10倍以上。

###### 1.优先在Eden区分配

​		如果启动本地线程分配缓冲TLAB-Thread Local Allocation Buffer，则优先在TLAB）如果Eden区满，则触发一次Minor GC

###### 2.大对象直接进入老年代；

​		大对象，即大量连续内存空间的Java对象，最典型的是那种很长的字符串及数组。

###### 3.长期存活的对象将进入老年代；

​		设置对象年龄计数器。对象在Eden出生并经过第一次MinorGC后仍存活，年龄+1，移入Survivor区。以后每经过一次MinorGC年龄加一，当达到15时（默认的）就进入老年代

###### 4.动态对象年龄判定，

​		并不是对象年龄必须达到最大阈值才会进入老年代。如果survivor空间中相同年龄所有对象大小总和大于其空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到阈值时才进入。

###### 5.【空间分配担保】；

​		发生minorGC之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，成立，MinorGC可以确保是安全的。不成立，则检查HandlePromotionFailure设置值是否允许担保失败。允许，则检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小。大于将尝试MinorGC，小于或者不允许冒险，也要进行一次FullGC。老年代分配担保，将survivor无法容纳的对象直接进入老年代。依然担保失败，则只好在失败后重新发起一次Full GC。

## **11.四种引用状态**

​	**1、强引用**（不会被垃圾回收）

代码中普遍存在的类似"Object obj = new Object()"这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

​	**2、软引用**（会在内存快要溢出的时候进行垃圾回收）

描述有些还有用但并非必需的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。Java中的类SoftReference表示软引用。

​	**3、弱引用**（会在内存进行回收时对其回收）

描述非必需对象。被弱引用关联的对象只能生存到下一次垃圾回收之前，垃圾收集器工作之后，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。Java中的类WeakReference表示弱引用。

​	**4、虚引用**（虚引用必须和引用队列关联使用）

这个引用存在的唯一目的就是在这个对象被收集器回收时收到一个系统通知，被虚引用关联的对象，和其生存时间完全没关系。Java中的类PhantomReference表示虚引用。

## 12.GC策略的指标

- 吞吐量           系统总运行时间=应用程序耗时+GC耗时。吞吐量=应用程序耗时/系统总运行时间。        吞吐量越高越好
- 垃圾回收器负载         垃圾回收器负载=GC耗时/系统总运行时间
- 停顿时间           垃圾回收器运行时，应用程序的暂停时间
- 垃圾回收频率         垃圾回收器多长时间运行一次。一般而言，频率越低越好，通常增大堆空间可以有效降低垃圾回收发生的频率，但是会增加回收时产生的停顿时间。
- 反应时间            当一个对象成为垃圾后，多长时间内，它所占用的内存空间会被释放掉。

## 13.Stop The World（停顿类型STW）

这些特定的指令**（安全点）位置主要在**：

- 1、循环的末尾
- 2、方法临返回前 / 调用方法的call指令后
- 3、可能抛异常的位置

**当垃圾收集器执行二次标记的时候，该对象也没有重写finalize()方法，因此回收的时候就会回收这个不该回收的对象。**【注意：重写finalize()方法后，一定要在方法内，对该对象进行重新引用，让收集器的标记方法，标记不到该对象】

## 14.JVM执行子系统1->类文件结构

   1). 魔数与Class文件版本 : 魔数可简单理解为一个符合JVM规范的class文件约定的常量, 版本号为随着JDK更新的版本号标识
    2). 常量池 : 可理解为class文件的资源仓库, 与其他项目关联最多的类型, 占用空间较大, 主要包含两类字面量和符号引用
    3). 访问标识 : 用于识别一些类或者接口层次的访问信息
    4). 类索引, 父类索引和接口索引集合 : 类索引, 父类索引和接口索引集合与常量池关联
    5). 字段表集合 : 描述接口或类中声名的变量, 包括类级别和实例级别, 不包括方法中的变量
    6). 方法表集合 : 描述方法的一些摘要信息包括访问标识, 名称索引, 描述符索引, 属性表集合等, 方法具体内容存在属性表集合中的Code属性里

## 15.JVM执行子系统2--->类加载机制

​	1.装载：查找和导入Class文件；

​	2.链接：把类的二进制数据合并到JRE中；
​        	  （a）校验：检查载入Class文件数据的正确性；
  		（b）准备：给类的静态变量分配存储空间；
  		（c）解析：将符号引用转成直接引用；（Class文件的常量池中存有大量的符号引用,）【主要是解析静态方法和私有方法这两大类】

​	3.初始化：对类的静态变量，静态代码块执行初始化操作

​	4.系统给我们提供的类加载器有四种：启动类加载器、扩展类加载器和系统类加载器、自定义加载器。

​		**启动类（Bootstrap）加载器：**它是由C++实现的本地方法，不属于Java类范畴，不能够被直接引用，主要被用于加载java所需的核心jar包，它负责将 <JAVA_HOME>/lib路径下的核心类库或-Xbootclasspath参数指定的路径下的jar包加载到内存								中，属于顶级类加载器。

​		**扩展类（Extension）加载器：** 它负责加载<JAVA_HOME>/lib/ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库。

​		**系统类（System）加载器：** 它负责加载系统类路径java -classpath或-D java.class.path 指定路径下的类库，也就是我们经常用到的classpath路径，开发者可以直接使用系统类加载器，一般情况下该类加载是程序中默认的类加载器，

​								通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器。

​		**Custom ClassLoader（自定义加载器）：**属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现。

```
	（2）类加载器的顺序（双亲委派机制） 
```

​			1）加载过程中会先检查类是否被已加载，**检查顺序是自底向上**，从System  ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。

​				而**加载的顺序是自顶向下**，也就是由上层来逐层尝试加载此类。 
​			2）在加载类时，每个类加载器会将加载任务上交给其父，如果其父找不到，再由自己去加载。 
​			3）Bootstrap Loader（启动类加载器）是最顶级的类加载器了，其父加载器为null。

​			4）如果System  ClassLoader也加载失败，就会抛出ClassNotFoundException

## 16.JVM执行子系统3->虚拟机字节码执行引擎

运行时栈桢结构 : 
    1). 局部变量表 : 用于存放方法参数和方法内部定义的局部变量.在Java程序编译为Class文件时,就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量
    2). 操作数栈 : 是一个后入先出（Last In First Out,LIFO）栈.同局部变量表一样,操作数栈的最大深度也在编译的时候写入到Code属性的max_stacks数据项中.操作数栈的每一个元素可以是任意的Java数据类型,包括long和double.32位数据类型所占的栈容量为1,64位数据类型所占的栈容量为2.在方法执行的任何时候,操作数栈的深度都不会超过在max_stacks数据项中设定的最大值.
    3). 动态链接 : 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用,持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）.我们知道Class文件的常量池中存有大量的符号引用,字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数.这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用,这种转化称为静态解析.另外一部分将在每一次运行期间转化为直接引用,这部分称为动态连接.（静态分派,动态分派）
    4). 方法返回地址 : 方法退出时可能执行的操作有:恢复上层方法的局部变量表和操作数栈,把返回值(如果有的话)压入调用者栈帧的操作数栈中,调整PC计数器的值以指向方法调用指令后面的一条指令等

​    5). 附加信息 : 虚拟机自定义实现

方法调用 : 
    1). 解析 : 解析调用时一个静态的过程, 在编译期间就完全确定, 在类装载的解析阶段就会把涉及的符号引用全部转换为直接引用(invokestatic, invokespecial都可在解析阶段确定调用版本)

​		【调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析。】
​    2). 分派 :**分派调用过程将会揭示多态性特征的一些最基本的体现，如“重载”和“重写”在Java虚拟中是如何实现的。**

​		 分为静态分派和动态分派, 以及单分派和多分派(依据宗量数)invokevirtual指令大部分场景

​		静态分派：发生在编译时期，所有依赖静态类型来定位方法执行版本的分派称为静态分派，典型应用为方法重载。

 		动态分派：在运行期根据实际类型确定方法执行版本的分派过程。典型应用为方法重写，实现是在方法去中建立方法表，若子类中没有重写父类方法，则子类虚方法表中该方法的入口地址与父类指向相同，否则子类方法表中地址会替换为指向子类重写的方法的入口地址。

​                 静态类型：编译期的类型，也就是等号的左边，对应的是父类

​		实际类型：运行期的类型，也就是等号的右边，对应的是子类

​		所有依赖静态类型来定位方法执行版本的分派动作称为静态分派.其典型应用是方法重载（根据参数的静态类型来定位目标方法）.
​                      静态分派发生在编译阶段.因此确定静态分派的动作实际上不是由虚拟机执行的.
​                         动态分派： 在运行期根据实际类型确定方法执行版本

​    3). 动态类型语言支持 : invokedynamic指令

​	**静态语言和动态语言的区别：**

- **静态语言（强类型语言）**： 
  静态语言是在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型。  
  例如：C++、Java、Delphi、C#等。
- **动态语言（弱类型语言）** ： 
  动态语言是在运行时确定数据类型的语言。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。  
  例如PHP/ASP/Ruby/Python/Perl/ABAP/SQL/JavaScript/Unix Shell等等。
- **强类型定义语言** ： 
  强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。举个例子：如果你定义了一个整型变量a,那么程序根本不可能将a当作字符串类型处理。强类型定义语言是类型安全的语言。
- **弱类型定义语言** ： 
  数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。强类型定义语言在速度上可能略逊色于弱类型定义语言，但是强类型定义语言带来的严谨性能够有效的避免许多错误。

基于栈的字节码解释执行引擎 : 
    1). 解释执行 :

​		Java语言中，javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程，因为这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机内部，所以Java程序的编译就是半独立实现的，

![解释执行](D:\BaiduYunDownload\面试题信息\面试题中的图片\解释执行.png)

​																					解释执行
​    2). 基于栈的指令集和基于寄存器的指令集 : 
​        java编译器输出的指令流, 基本上都是基于栈的指令集(ISA), 不同于基于寄存器的指令集,

​		 基于栈的指令集的一个优点是可移植, 因为寄存器由硬件提供,程序依赖于寄存器不能避免会受到硬件的约束, 主要缺点是相对来说慢一些, 因为要进行很多入栈出栈等操作
​    3). 基于栈的解释器的执行过程 :    

​        主要是由栈桢中的程序计数器, 局部变量表, 操作数栈协同工作, 实际的虚拟机实现会做出一些优化来提升性能, 实际的运作过程可能不是很符合模型概念的描述, 主要的原因是虚拟机中的解释器和即时编译器都会对输入的字节码进行优化

## 17.java虚拟机new一个对象的创建过程

在常量池中查看是否有new的参数对应的类的符号引用，并检查这个符号引用对应的类是否被加载、解析、初始化
 加载后，为新对象分配内存空间，对象多需要的内存大小在类被加载之后就被确定（堆内分配内存：指针碰撞、空闲列表）。
 将分配的空间初始化为零值。
 对对象头进行必要设置（实例是哪个类的实例、类的元信息数据、GC分代年龄等）。
 执行方法，按照程序的值初始化。

## 18.对象的内存布局

对象内存布局分为三部分：对象头、实例数据、对齐填充。

对象头包含两部分：

存储对象自身运行时数据：哈希码、分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等
 对象指向它的类元数据指针–类型指针
 实例数据：程序代码中所定义的各种类型的字段内容

对齐填充：不是必然存在，仅起到占位符作用（对象大小必须是8子节整数倍



## 19.Jvm监控和故障处理工具

​	jps：JVM Process Status Tool ,显示指定系统内所有的HotSpot虚拟机进程
​	jstat: JVM Statistics Monitoring Tool ,用于收集HotSpot虚拟机各方面的运行数据。
​	jinfo: Configuration Info forJava,显示虚拟机配置信息
​	jmap: Memory Map for Java，生成虚拟机的内存转储快照（heapdump文件）
​	jhat: JVM Heap Dump Browser ,用于分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果



## 20.程序编译与代码优化：早期（编译期）优化

【前期编译：把*.java文件转变成*.class文件的过程】

前端编译器：Sun的Javac、Eclipse JDT中的增量式编译器（ECJ）。

JIT编译器：HotSpot VM的C1、C2编译器。

AOT编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。

javac的编译过程：

​	1.解析与填充符号表：

```
		1.1.词法、语法分析
```

​			词法分析是将源代码的字符流转变为标记（Token）集合，单个字符是程序编写过程的最小元素，而标记则是编译过程的最小元素，关键字、变量名、字面量、运算符都可以成为标记。

​			语法分析是根据Token序列构造抽象语法树的过程，抽象语法树（Abstract Syntax Tree,AST）是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构（Construct）。

​		1.2.填充符号表

​			符号表（Symbol Table）是由一组符号地址和符号信息构成的表格。

​			符号表中所登记的信息在编译的不同阶段都要用到。在语义分析中，符号表所登记的内容将用于语义检查（如检查一个名字的使用和原先的说明是否一致）和产生中间代码。在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分	配的依据。

​	2.插入式注解处理器的注解处理过程

​		在JDK 1.6中实现了JSR-269规范[1]，提供了一组插入式注解处理器的标准API在编译期间对注解进行处理，我们可以把它看做是一组编译器的插件，在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素。

​	3.语义分析与字节码生成

```
		3.1.标注检查  
```

​			标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等。 

​		3.2.数据及控制流分析  

​			数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。 

​			编译时期的数据及控制流分析与类加载时的数据及控制流分析的目的基本上是一致的，但校验范围有所区别，有一些校验项只有在编译期或运行期才能进行。 

​		3.3.解语法糖 

​			语法糖（Syntactic Sugar），也称糖衣语法，是由英国计算机科学家彼得·约翰·兰达（Peter J.Landin）发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说，使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。 

​		3.4.字节码生成 

字节码生成是Javac编译过程的最后一个阶段，在Javac源码里面由com.sun.tools.javac.jvm.Gen类来完成。字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。



## 21.程序编译与代码优化：晚期（运行期）优化

【后期编译：把字节码转变成机器码的过程】

#### 1.HotSpot虚拟机内的即时编译器

###### 1.1解释器与编译器

​		解释器与编译器两者各有优势：当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。

​		HotSpot虚拟机中内置了两个即时编译器，分别称为Client Compiler和Server Compiler，或简称为C1编译器和C2编译器（也叫Opto编译器）。目前主流的HotSpot虚拟机中，默认采用解释器与其中一个编译器直接配合的方式工作，程序使用哪个编译器，取决于虚拟机运行的模式，HotSpot虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式，用户也可以使用-client或-server参数去强制指定虚拟机运行在Client模式或Server模式。

​		由于即时编译器编译本地代码需要占用程序运行时间，要编译出优化程度更高的代码，所花费的时间可能更长；而且想要编译出优化程度更高的代码，解释器可能还要替编译器收集性能监控信息，这对解释执行的速度也有影响。为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot虚拟机还会逐渐启动分层编译（Tiered Compilation）的策略。

​		分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次，其中包括：

- 第0层，程序解释执行，解释器不开启性能监控功能，可触发第1层编译；
- 第1层，也称为C1编译，将字节码编译为本地代码，进行监督、可靠的优化，如有必要将加入性能监控的逻辑；
- 第2层（或2层以上），也称为C2编译，也是讲字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。

实施分层编译后，Client Compiler和Server Compiler将会同时工作，许多代码都可能会被多次编译，用Client Compiler获取更高的编译速度，用Server Compiler来获取编译质量，在解释执行的时候也无须再承担收集性能监控信息的任务。

###### 1.2 编译对象与触发条件

​		在运行过程中会被即时编译器编译的“热点代码”有两类，即：

- 被多次调用的方法；

- 被多次执行的循环体；

  ​	对于第一种情况，由于是方法调用触发的编译，因此编译器理所当然会以整个方法作为编译对象，这种编译也是虚拟机中标准的JIT编译方式，而对于后一种情况，尽管编译动作是由循环体所触发的，但编译器依然会以整个方法（而不是单独的循环体）作为编译对象。这种编译方式因为编译发生在方法执行过程中，因此形象地称为栈上替换（On Stack Replacement，简称为OSR编译，即方法栈帧还在栈上，方法就被替换了）。

  ​	判断一段代码是不是热点代码，是不是需要出发即时编译，这样的行为称为热点探测（Hot Spot Detection），其实进行热点探测并不一定要知道方法具体被调用多少次，目前主要的热点探测判定方式有两种，分别如下：

- 基于采样的热点探测（Sample Based Hot Spot Detection）

- 基于计数器的热点探测（Counter Based Hot Spot Detection）

  ​	在HotSpot中使用了基于计数器的热点探测方法，因此为每个方法准备两类计数器：方法调用计数器和回边计数器。在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阈值，当计数器超过阈值，就会触发JIT编译。

  ​	默认阈值在 Client 模式下是 1500 次，在 Server 模式下是 10000 次

###### 1.3 编译过程

​			1.3.1 Client Compiler【字节码-->高级中间码-->低级中间码-->产生机器代码】

​				对于ClientCompiler来说，它是一个简单快速的三段式编译器，主要的关注点在于局部性的优化，而放弃了许多耗时较长的全局优化手段。

- 第一个阶段，一个平台独立的前端将字节码构造成一种高级中间代码表示（HIR），在此之前编译器会在字节码上完成一部分基础优化，如方法内联、常量传播等优化将会在字节码被构造成HIR之前完成

- 第二个阶段，一个平台相关的后端从高级中间代码表示（HIR）中产生低级中间代码表示（LIR），在此之前会在HIR上完成另外一些优化，如空值检查消除、范围检查消除等。

- 第三个阶段，平台相关的后端使用线下扫描算法，在LIR上分配寄存器，并在LIR上做窥空优化，然后产生机器代码

  ​		流程如下图：

![Client Compiler的编译过程](D:\BaiduYunDownload\面试题信息\面试题中的图片\Client Compiler的编译过程.png)

​			1.3.2 Server Compiler

​				Server Compiler是专门面向服务端的典型应用并未服务端的性能配置特别调整过的编译器，也是一个充分优化过的高级编译器，几乎达到GUN C++编译器使用-O2参数时的优化强度，它会执行所有经典的优化动作，如无用代码消除，循			环展开，循环表达式外提，消除公共子表达式，常量传播，基本块重排序等。还会实施一些与Java语言特性密切相关的优化技术，如范围检查消除，空值检查消除。

###### 1.4 查看及分析即时编译结果

​		一般来说，虚拟机的即时编译过程对用户程序时完全透明的，虚拟机通过解释执行代码还是编译执行代码，对于用户来说并没有什么影响。但是虚拟机也提供了一些参数用来输出即时编译和某些优化手段（如方法内联）的执行状态。

#### 2.编译优化技术

​		以编译方式执行本地代码比解释方式更快，除去虚拟机解释执行字节码时额外消耗时间的原因外，还有一个很重要的原因就是虚拟机几乎把对代码的所有优化措施都集中在了即时编译器之中。因此一般来说，即时编译器产生的本地代码会比javac产生的字节码更加优秀。

###### 2.1优化技术概览

优化技术主要分为如下几类：（1）编译器策略（2）基于性能监控的优化技术（3）基于证据的优化技术（4）数据流敏感重写（5）语言相关的优化技术（6）内存及代码位置变换（7）循环变换（8）全局代码调整（9）控制流图变换 

###### 2.2公共子表达式消除

【语言无关的经典优化技术之一】

​		int d=（c * b）*12+a+（a+b * c）；

​		当这段代码进入到虚拟机即时编译器后，它将进行如下优化：编译器检测到“c * b”与“b * c”是一样的表达式，而且在计算期间b与c的值是不变的。因此，这条表达式就可能被视为：

​		int d=E*12+a+（a+E）

###### 2.3数组边界检查消除

【语言相关的经典优化技术之一】

​		数组边界检查消除（Array Bounds Checking Elimination）是即时编译器中的一项语言相关的经典优化技术。【编译的时候，每一次的读写操作时，都不用再去检查数组的上下界，】是根据数据流分析

###### 2.4方法内联

【最重要的优化技术之一】

​		除了消除方法调用的成本之外，它更重要的意义是为其他优化手段建立良好的基础

###### 2.5逃逸分析

【最前沿的优化技术之一】

【最主要就是分析：新创建的类是否逃逸到方法外，如果不逃逸，就可以进一步优化该变量的存储】

​		逃逸分析（Escape Analysis）是目前Java虚拟机中比较前沿的优化技术，它与类型继承关系分析一样，并不是直接优化代码的手段，而是为其他优化手段提供依据的分析技术。

​		逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，称为方法逃逸。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。

​		栈上分配（Stack Allocation）：也就是如果逃逸分析到，新创建的对象不会逃逸到方法外，那么这个对象可以让它的内存分配到栈上，那么随着栈的弹栈，该对象就会销毁，这样就减轻了垃圾收集系统的压力。

​		同步消除：线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以消除掉。

​		标量替换（Scalar Replacement）：标量：就是一个数据已经无法再分解成更小的数据来表示，原始数据类型（int等）就是标量，把类中的成员变量变成标量表示



- 

## 22.Java内存模型中的happen-before是什么

**happen-before原则是JMM中非常重要的原则，它是判断数据是否存在竞争、线程是否安全的主要依据，保证了多线程环境下的可见性。**

​	概念：    用happens-before的概念来阐述操作之间的内存可见性。在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系 【.先行发生原则(Happen-before)】

​	**1. 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。** 
​	**2. 两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序合法。**

下面是happens-before原则规则：

1. 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；
2. 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作；
3. volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；
4. 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；
5. 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；
6. 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；【只有先调用了该方法，才能监测到该线程被中断，相当于监听器】
7. 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；
8. 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；

上面八条是原生Java满足Happens-before关系的规则，但是我们可以对他们进行推导出其他满足happens-before的规则：

1. 将一个元素放入一个线程安全的队列的操作Happens-Before从队列中取出这个元素的操作
2. 将一个元素放入一个线程安全容器的操作Happens-Before从容器中取出这个元素的操作
3. 在CountDownLatch上的倒数操作Happens-Before CountDownLatch#await()操作
4. 释放Semaphore许可的操作Happens-Before获得许可操作
5. Future表示的任务的所有操作Happens-Before Future#get()操作
6. 向Executor提交一个Runnable或Callable的操作Happens-Before任务开始执行操作

## 23.内存溢出和内存泄露

​	1.内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；

​	2.内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。

​		memory leak会最终会导致out of memory！

```
 	以发生的方式来分类，内存泄漏可以分为4类： 
```

​		2.1常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。 

​		2.2偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。 

​		2.3一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。 

​		2.4 隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。 

​	内存泄露是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成的内存空间的浪费称为内存泄露。内存泄露有时不严重且不易察觉，这样开发者就不知道存在内存泄露，但有时也会很严重，会提示你Out of memory。那么，Java内存泄露根本原因是什么呢？长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。具体主要有如下几大类： 

1、静态集合类引起内存泄露： 

2、当集合里面的对象属性被修改后，再调用remove（）方法时不起作用。

3、监听器 

4、各种连接 

5、单例模式

## 24.jvm常用内存参数设置

1.常用参数

​	-Xms  初始堆（heap）内存值

​	-Xmx 可申请的最大堆（heap）值

​	-Xmn 新生代内存大小

​	-Xss 每个线程栈的大小（jdk1.5以后为1M）

​	-XX:PermSize  方法区的初始内存大小

​	-XX:MaxPermSize  方法区的最大内存大小

```
	-XX:+UseSerialGC　串行（SerialGC）是jvm的默认GC方式，一般适用于小型应用和单处理器，算法比较简单，GC效率也较高，但可能会给应用带来停顿。
```

　　-XX:+UseParallelGC   并行（ParallelGC）是指多个线程并行执行GC，一般适用于多处理器系统中，可以提高GC的效率，但算法复杂，系统消耗较大。（配合使用：-XX:ParallelGCThreads=8，并行收集器的线程数，此值最好配置与处理器数目相等）

　　-XX:+UseParNewGC     设置年轻代为并行收集，JKD5.0以上，JVM会根据系统配置自行设置，所以无需设置此值。

　　-XX:+UseParallelOldGC　设置年老代为并行收集，JKD6.0出现的参数选项。

　　-XX:+UseConcMarkSweepGC　并发（ConcMarkSweepGC）是指GC运行时，对应用程序运行几乎没有影响（也会造成停顿，不过很小而已），GC和app两者的线程在并发执行，这样可以最大限度不影响app的运行。

　　-XX:+UseCMSCompactAtFullCollection　在Full GC的时候，对老年代进行压缩整理。因为CMS是不会移动内存的，因此非常容易产生内存碎片。因此增加这个参数就可以在FullGC后对内存进行压缩整理，消除内存碎片。当然这个操作也有一定缺点，就是会增加CPU开销与GC时间，所以可以通过-XX:CMSFullGCsBeforeCompaction=3 这个参数来控制多少次Full GC以后进行一次碎片整理。

　　-XX:+CMSInitiatingOccupancyFraction=80　代表老年代使用空间达到80%后，就进行Full GC。CMS收集器在进行垃圾收集时，和应用程序一起工作，所以，不能等到老年代几乎完全被填满了再进行收集，这样会影响并发的应用线程的空间使用，从而再次触发不必要的Full GC。

　　-XX:+MaxTenuringThreshold=10  新生代进入老年代的临界值

## 25.NIO与IO的区别

```
IO                NIO
面向流            面向缓冲
阻塞IO            非阻塞IO
无                选择器
```

#### 1.面向流与面向缓冲

​	Java NIO和IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。IO是逐字读取文件所有的东西，它并没有存放到任何地方，如果需要操作里面的数据，可以先读取到一个缓冲区。

​	NIO是，把数据读取到一个它稍后处理的缓冲区中，需要时，可在缓冲区中，前后移动来获取想要的数据

#### 2.阻塞IO与非阻塞NIO

​	Java IO的各种流是阻塞的，也就是，当一个线程调用write()或read()时，该线程会进入阻塞状态，直到数据被写入完，或读取完，该线程在此期间不能再干任何事情。

​	Java NIO则是非阻塞的，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，直至数据变得可以读之前，该线程可以继续做其他的事情，

非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作。

#### 3.选择器（Selectors）

​	Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。

#### **4.NIO和IO如何影响应用程序的设计**

无论您选择IO或NIO工具箱，可能会影响您应用程序设计的以下几个方面：

1. 对NIO或IO类的API调用。
2. 数据处理。
3. 用来处理数据的线程数。

## 26.NIO

​	1.NIO的主要组成部分：

​		1.1Buffer：缓冲区

​		1.2Channel：通道

​		1.3Selectors：选择器

​		1.4Chartset：字符集

​	2.Scatter/Gather

​		Scatter：将读取到的数据分开放置到多个存储的桶中（Bucket）

​		Gather：将不同的数据区块合并成一个整体

## 27.HashMap的源码，实现原理，JDK8中对HashMap做了怎样的优化。

​	JDK1.7之前： 数组+链表结构

​	JDK1.8之后：数组+链表（红黑树）结构

JDK8中对HashMap做了怎样的优化：

​	1.生成一个entry初始容量16的数组+链表结构,使用容量大于0.75f时,自动扩容2^n         负载因子0.75

​	2.当链表长度大于8时,转化为红黑树结构.

## 28.HashMap扩容是怎样扩容的，为什么都是2的N次幂的大小。

​	因为hashMap中计算index的方法是：index = hash & (tab.length – 1)  ，同时，HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同

​		2的n次方实际就是1后面n个0，2的n次方-1  实际就是n个1，这样就能减少hash碰撞，同时也也能把数据均匀分配到表中

## 29.hashMap和hashTable，ConcurrentHashMap（JDK1.7和JDK1.8实现原理不同）的区别。

#### 1.HashTable

- 底层数组+链表实现，无论key还是value都**不能为null**，线程**安全**，实现线程安全的方式是在修改数据时锁住整个HashTable，效率低，ConcurrentHashMap做了相关优化
- 初始size为**11**，扩容：newsize = olesize*2+1
- 计算index的方法：index = (hash & 0x7FFFFFFF) % tab.length

#### 2.HashMap

- 底层数组+链表实现，可**以存储null键和null值**，线程**不安全**
- 初始size为**16**，扩容：newsize = oldsize*2，size一定为2的n次幂
- 扩容针对整个Map，每次扩容时，原来数组中的元素依次重新计算存放位置，并重新插入
- 插入元素后才判断该不该扩容，有可能无效扩容（插入后如果扩容，如果没有再次插入，就会产生无效扩容）
- 当Map中元素总数超过Entry数组的75%，触发扩容操作，为了减少链表长度，元素分配更均匀
- 计算index方法：index = hash & (tab.length – 1)

#### 3.ConcurrentHashMap（JDK1.7，采用分段锁机制）

- 底层采用分段的数组+链表实现，线程**安全**
- 通过把整个Map分为N个Segment，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。(读操作不加锁，由于HashEntry的value变量是 volatile的，也能保证读取到最新的值。)
- Hashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术
- 有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁
- 扩容：段内扩容（段内元素超过该段对应Entry数组长度的75%触发扩容，不会对整个Map进行扩容），插入前检测需不需要扩容，有效避免无效扩容

分段锁机制：
		Hashtable之所以效率低下主要是因为其实现使用了synchronized关键字对put等操作进行加锁，而synchronized关键字加锁是对整个对象进行加锁，也就是说在进行put等修改Hash表的操作时，锁住了整个Hash表，从而使得其表现的效率低下；因此，在JDK1.5~1.7版本，Java使用了分段锁机制实现ConcurrentHashMap.
		简而言之，ConcurrentHashMap在对象中保存了一个Segment数组，即将整个Hash表划分为多个分段；而每个Segment元素，即每个分段则类似于一个Hashtable；这样，在执行put操作时首先根据hash算法定位到元素属于哪个Segment，然后对该Segment加锁即可。因此，ConcurrentHashMap在多线程并发编程中可是实现多线程put操作。接下来，本文将详细分析JDK1.7版本中ConcurrentHashMap的实现原理。

#### 4.ConcurrentHashMap（JDK1.8，采用CAS和synchronized）

```
	ConcurrentHashMap是通过分段锁机制来实现的，所以其最大并发度受Segment的个数限制。因此，在JDK1.8中，ConcurrentHashMap的实现原理摒弃了这种设计，而是选择了与HashMap类似的数组+链表+红黑树的方式实现，而加锁则采用CAS和synchronized实现。
	
CAS原理（乐观锁的一种实现方式）：
		一般地，锁分为悲观锁和乐观锁：悲观锁认为对于同一个数据的并发操作，一定是为发生修改的；而乐观锁则任务对于同一个数据的并发操作是不会发生修改的，在更新数据时会采用尝试更新不断重试的方式更新数据。

		CAS（Compare And Swap，比较交换）：CAS有三个操作数，内存值V、预期值A、要修改的新值B，当且仅当A和V相等时才会将V修改为B，否则什么都不做。Java中CAS操作通过JNI本地方法实现，在JVM中程序会根据当前处理器的类型来决定是否为cmpxchg指令添加lock前缀。如果程序是在多处理器上运行，就为cmpxchg指令加上lock前缀（Lock Cmpxchg）；反之，如果程序是在单处理器上运行，就省略lock前缀。、
		
CAS容易出现的三个问题：

	1. 注意：CAS可能导致ABA问题，就是一个线程1先将A变成B，然后又将数据变成A，此时线程1发现内置位置仍是A，就会操作成功，但并不代表这个操作过程就没有问题。

		解决ABA问题：部分乐观锁的实现是通过版本号（version）来解决ABA问题的，每次去修改/更新一个数据时，会带上版本号，一旦版本号和数据的版本号一致时就会一致就可以执行修改/更新操作，并将版本号+1；

	2.多线程竞争时，线程长时间拿不到锁会做无意义的自旋，给CPU资源带来一定程度的消耗。
	
		解决方法：破坏掉for死循环，当超过一定时间或者一定次数时，return退出。JDK8新增的LongAddr,和ConcurrentHashMap类似的方法。当多个线程竞争时，将粒度变小，将一个变量拆分为多个变量，达到多个线程访问多个资源的效果，最后再调用sum把它合起来。

	3.只能保证一个共享变量的原子性操作
	
		解决方法： CAS操作是针对一个变量的，如果对多个变量操作，1. 可以加锁来解决。2 .封装成对象类解决。
	
```

## 30.HashMap在高并发下如果没有处理线程安全会有怎样的安全隐患，具体表现是什么

```
1.多线程put时可能会导致get无限循环，具体表现为CPU使用率100%；
```

​		原因：在向HashMap put元素时，会检查HashMap的容量是否足够，如果不足，则会新建一个比原来容量大两倍的Hash表，然后把数组从老的Hash表中迁移到新的Hash表中，迁移的过程就是一个rehash()的过程，多个线程同时操作就有可能会形成循环链表，所以在使用get()时，就会出现Infinite Loop的情况

2、多线程put时可能导致元素丢失
		原因：当多个线程同时执行addEntry(hash,key ,value,i)时，如果产生哈希碰撞，导致两个线程得到同样的bucketIndex去存储，就可能会发生元素覆盖丢失的情况

**建议：使用Hashtable 类，Hashtable 是线程安全的；使用并发包下的java.util.concurrent.ConcurrentHashMap，ConcurrentHashMap实现了更高级的线程安全；或者使用synchronizedMap() 同步方法包装 HashMap object，得到线程安全的Map，并在此Map上进行操作。**

## 31.一个ArrayList在循环过程中删除，会不会出问题，为什么？

#### 1.使用普通for：

​		删除不会出问题

#### 2.使用迭代器（删除后继续遍历）：

​		删除会出现问题，同时抛出ConcurrentModificationException异常

#### 3.使用迭代器（删除后跳出循环）：

​		删除不会出问题

#### 总结：迭代器会检查modCount是否改变

```
	错误原因都是ArrayList集合中remove方法底层的源码中有一个fastRemove(index)方法，然后会有一个modCount++的操作，然后在ArratList内部的迭代器中有一个checkForComodification操作，也就是检查modCount是否改变，如果改变了，就抛出并发修改错误。同样的在For each增强for循环中，也是利用了ArrayList自身的Iterator迭代器，也是会出现这样的错误。
```

## 32.一致性hash算法的原理及应用

​	在解决分布式系统中负载均衡的问题时候可以使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），起到负载均衡的作用。

​	在分布式系统中一致性hash起着不可忽略的地位，无论是分布式缓存，还是分布式Rpc框架的负载均衡策略都有所使用

#### 一致性hash算法的原理：（环形Hash空间）

 一致性Hash算法提出了在动态变化的Cache环境中，判定哈希算法好坏的四个定义：

###### 1、平衡性（Balance）：

​	平衡性是指哈希的结果能够尽可能分布在所有的缓冲(Cache)中去，这样可以使得所有的缓冲空间得到利用。很多哈希算法都能够满足这一条件。

###### 2、单调性（Monotonicity）：

​	单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应该能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会映射到旧的缓冲集合中的其他缓冲区。

###### 3、分散性（Spread）：

​	在分布式环境中，终端有可能看不到所有的缓冲，而只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上去，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应该能够尽量避免不一致的情况发生，也就是尽量降低分散性。

###### 4、负载（Load）：

​	负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射到不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。

#### 一致性hash算法的应用：

###### 1.Redis集群模式也使用了一致性hash算法：

(1)所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.

(2)节点的fail是通过集群中超过半数的节点检测失效时才生效.

(3)客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可

(4)redis-cluster把所有的物理节点映射到[0-16383]slot（插槽）上,cluster 负责维护node<->slot<->value

## 33.hash算法

​	1.**除法散列法** 

​	2.**平方散列法** 

​	3.**斐波那契（Fibonacci）散列法**

## 34.ArrayList的扩容机制

​	ArrayList的扩容机制：

​		1.初始容量为10，

​		2.每次扩容为原来的1.5倍（使用位运算符>>）（相当于加上了原来的0.5倍，如果为奇数，则向下取整）

## 35.数据结构

​	1.栈结构（先进后出）

​	2.队列结构（先进先出）

​	3.数组结构（查询快，增删慢）

​	4.链表结构（增删快，查询慢）

​	5.树结构（查询快，增删快）

​	6.特殊的数据额结构

​		1.哈希表（散列表）底层是数组+链表/红黑树，采用链地址法（查询快，增删快）

​		2.有序队列-->堆结构（完美的二叉树，可以用数组表示）

​		3.红黑树

​	7.图结构

## 36.八大排序算法的时间复杂度![八大排序算法](D:\BaiduYunDownload\面试题信息\面试题中的图片\八大排序算法.png)

快(快速排序)些(希尔排序)选(选择排序)一堆(堆排序)朋友来聊天吧，我这样记的，其余的都是稳定排序

1.基本有序，不适合快速排序【快排说简单了就是：从最右找到第一个小于poviot的数，与之交换；然后再从最左找到第一个大于poviot的数，与之交换；这样循环往复，直到poviot右边的数都大于左边，左边的数都大于右边】

## 37.常量优化机制

1. 在给变量进行赋值的时候，如果右侧的表达式当中全都是常量，没有任何变量，那么编译器javac将会直接将若干个常量表达式计算得到结果。

​	2.在两个变量的数据类型一样时：a+=b 和a=a+b 是没有区别的。但是当两个变量的数据类型不同时，就需要考虑一下数据类型自动转换的问题了。也就是涉及到精度了。

​	3.1 如果常量池中有像创建的对象，则仅仅是将地址指向这个常量即可。

​	3.2 如果是几个字符组成的字符串，变成字符串常量的时候，也是遵循上一条规定；

​		String s1 = "a"+"b"+"c";

​		String s2 = "abc";

​		System.out.println(s1== s2);

​		结果是ture，这表明，s1和s2共用一个内存地址，这体现了Java中的常量优化机制。

## 38.lambda表达式线程池的坑

  public void testFunction(Object obj) {
  Runnable runnable = () -> {使用obj参数做一些操作}
  TaskService.execute(runnable);
  return ;
	}

现在有个问题，如果在短时间内多次call这个函数，每次传入的obj参数都不同，可能会出现每个runnable中使用的object都是最后一次调用函数时传的参数，请问这种现象有没有个特定的名字，百度了一顿没有搜到，有没有什么方法解决呢？  

解决方法：闭包延迟绑定，obj是引用，线程异步处理的时候就可能是最后一个。可以把obj做复制，参数传递到lambda，互不干扰。

## 39.switch表达式的数据类型有

switch语句中，表达式的数据类型，可以是byte，short，int，char，enum（枚举），JDK7后可以接收字符串

## 40.方法的重写（override）两同两小一大原则：

方法名相同，参数类型相同

子类返回类型小于等于父类方法返回类型，

子类抛出异常小于等于父类方法抛出异常，

子类访问权限大于等于父类方法访问权限。

## 41.内部类

在Java中，可以将一个类定义在另一个类里面或者一个方法里边，这样的类称为内部类，广泛意义上的内部类一般包括四种：成员内部类，局部内部类，匿名内部类，静态内部类 。

1.成员内部类

（1）该类像是外部类的一个成员，可以无条件的访问外部类的所有成员属性和成员方法（包括private成员和静态成员）；

（2）成员内部类拥有与外部类同名的成员变量时，会发生隐藏现象，即默认情况下访问的是成员内部类中的成员。如果要访问外部类中的成员，需要以下形式访问：【外部类.this.成员变量  或  外部类.this.成员方法】；

（3）在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问；

（4）成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象；

（5）内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。如果成员内部类用private修饰，则只能在外部类的内部访问；如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。外部类只能被public和包访问两种权限修饰。

2.局部内部类

（1）局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内；

（2）局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。

3.匿名内部类

（1）一般使用匿名内部类的方法来编写事件监听代码；

（2）匿名内部类是不能有访问修饰符和static修饰符的；

（3）匿名内部类是唯一一种没有构造器的类；

（4）匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。

4.内部静态类

（1）静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似；

（2）不能使用外部类的非static成员变量或者方法。

## 42.java方法中的值传递和引用传递

- 如果参数是基本类型，传递的是基本类型的字面量值的拷贝。【值传递】
- 如果参数是引用类型，传递的是该参量所引用的对象在堆中地址值的拷贝。【引用传递】

## 43.如何确保三个线程顺序执行？

​	1.**使用join**

​	2.使用CountDownLatch（闭锁）

​	3.CachedThreadPool

​	4.使用blockingQueue

​	5.使用单个线程池

## 44.Integer以及int之间的几种比较

下面的讨论都不针对新开辟对象的情况：
1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true；
2、两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。
3、两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true
4、基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。



## 45.程序设计的通用规则

1：将局部变量的作用域最小化
2：for-each循环优先于传统的for循环
3：如果需要精确计算，避免使用float和double，尽量使用int,long,Bigdecimal
4:基本类型优先于装箱基本类型
5：字符串连接应优先选择stringBuffer,stringBulider
6：尽量通过接口来引用对象

## 46.网络的七层（从上往下依次）

1.应用层   	application

2.表示层	presentation   

3.会话层	session

4.传输层	tansport

5.网络层	network

6.数据链路层	datalink

7.物理层	physical

## 47.三次握手

第一次握手，客户端向服务器端发出连接请求，等待服务器确认。 

第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。 

第三次握手，客户端再次向服务器端发送确认信息，确认连接。

## 48.四次挥手

```
第一次挥手：
```

​	Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。

第二次挥手：
	Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。

第三次挥手：
	Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。

第四次挥手：

​	Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手



## 49.长连接和短连接

长连接：TCO建立之后就是长连接了，只要你不断开可以一直进行数据的伟输。
		长连接适用于要进行大量数据传输的情况，如：数据库，redis,memcached等要求快速，数据量大的情况下。
		长连接通过心跳机制（通信数据很少）来进行连接状态的监测，断后重新进行连接。

短连接：每发起一次请求都建立TCP连接,响应请求后就断开连接，这样防止客户端长期占用服务器的资源，维持连接是要占用线程的。

　	**在HTTP/1.0中，默认使用的是短连接**。

 	**HTTP/1.1起，默认使用长连接**，：

## 50.java中的设计模式

​	java中一般认为有23种设计模式

​	  总体来说设计模式分为三大类：

​     （1）创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。（普通工厂）

​     （2）结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

​     （3）行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

## 51.设计模式的六大原则（降低依赖，降低耦合）

​	**1、开闭原则（Open Close Principle）**

​		开闭原则就是说**对扩展开放，对修改关闭**。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

​		开闭原则就是说对扩展开放，对修改关闭

​	**2、里氏代换原则（Liskov Substitution Principle）**

​		里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

```
	eg：子类的访问权限必须高于等于父类的访问权限
```

​	**3、依赖倒转原则（Dependence Inversion Principle）**

​		这个是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。

​	**4、接口隔离原则（Interface Segregation Principle）**

​		这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。

​	**5、迪米特法则（最少知道原则）（Demeter Principle）**

​		为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。

​	**6、合成复用原则（Composite Reuse Principle）**

​		原则是尽量使用合成/聚合的方式，而不是使用继承。

## 52.简单工厂，工厂方法和抽象工厂的区别

1. 简单工厂：产品类和工厂类耦合在一起。
2. 工厂方法：产品类未抽象，工厂抽象出来了。 
3. 抽象工厂：产品和工厂都抽象出来了，完全解耦合。

## 53.适配器模式与装饰器模式有什么区别？

​	虽然适配器模式和装饰器模式的结构类似，但是每种模式的出现意图不同。适配器模式被用于桥接两个接口，而装饰模式的目的是在不修改类的情况下给类增加新的功能。

​		1.装饰者模式：动态地将责任附加到对象上，若要扩展功能，装饰者模提供了比继承更有弹性的替代方案。通俗的解释：装饰模式就是给一个对象增加一些新的功能，而且是动态的，

要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。

​		2.适配器模式：将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。
​			适配器模式有三种：类的适配器模式、对象的适配器模式、接口的适配器模式。 通俗的说法：适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。



## 54.适配器模式的理解【个人理解】

一个计算机接口及一个实现类，一个SD接口及其实现类（u盘），一个TF接口及其实现类（内存卡），一个适配器类，

适配器类去实现SD接口（适配器相当于U盘），并在成员变量位置TF接口，实现SD接口的方法，在SD接口实现的方法中，调用TF的方法。【这就是适配器模式的理解】

在这种模式下，计算机并不需要知道具体是什么卡，只需要负责操作接口即可，具体操作的什么类，由适配器决定。

## 55.装饰器模式的理解【个人理解】

一个被装饰的接口，及其很多的实现类，一个抽象类（也就是装饰类）实现这个接口，类中加入这个接口的成员变量，重写的方法里面，用这个成员调用其方法

一个扩展类，继承这个抽象类，其中可以有自己的方法，同时重写抽象类的方法，里面可以调用自己的方法，也可以调用成员变量的方法。

【必须实现同一个接口】

## 56.策略模式的理解【个人理解】

一个接口，及其许多的实现类，一个context类，里面的成员变量注入这个接口，在这个context的方法中调用这个接口的方法

我们创建context类时传入不同的接口的实现类，那面实际调用的方法就不同。

## 57.代理模式的理解【个人理解】

动态代理：代理类和被代理类实现同样的接口，

cglib代理：相当于代理类继承了被代理类

## 58.观察者模式的理解【个人理解】

​	观察者模式又被称作发布/订阅模式，定义了对象间一对多依赖，当一个对象改变状态时，它的 所有依赖者都会收到通知并自动更新。 【有点像监听器】redis中的哨兵模式

应用场景： 

1. 对一个对象状态的更新，需要其他对象同步更新，而且其他对象的数量动态可变。 

2. 对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节。

## 59.模板方法的理解【个人理解】

​	模板方法模式定义一个操作中的算法的骨架，将一些步骤延迟到子类中，模板方法使得子类 可以不改变一个算法的结构即可重定义该算法的某些步骤。 【spring中很多都是模板，例如jdbctemplate】

​	父类有一个方法（该方法最好不能被重写），该方法中调用父类的其他方法，子类继承父类，然后重写被调用的其他方法【不同的子类，重写的方法是不一样的，但是调用方法的步骤是一样的】

应用场景： 

​	对于一些功能，在不同的对象身上展示不同的作用，但是功能的框架是一样的。

## 60.迭代器模式的理解【个人理解】

​	迭代器模式提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。 【JAVA 中的 iterator就是很好的一种迭代器】

应用场景： 

​	当你需要访问一个聚集对象，而且不管这些对象是什么都需要遍 历的时候，就应该考虑用迭代器模式。其实 stl容器就是很好的迭代器模式的例子。

## 61.访问者模式的理解【个人理解】

主要将数据结构与数据操作分离。

就像访问数据库一样，不同的方式【crud】，操作同一个对象【数据库】

## 62.单例模式及懒汉式和饿汉式【个人理解】

​	单例模式就是：【构造方法私有化】

​	注意：

​		1.单例类只能有一个实例

​		2.单例类必须自己创建自己的唯一实例

​		3.单例类必须给所有其他对象提供这一实例

懒汉式：第一次调用方法是初始化实例对象

饿汉式：类加载进内存时，就初始化实例对象

## 63.原型模式的理解【个人理解】

用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

java中，通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，所以可以使用原型模式，也就是JAVA 中的 Object clone() 方法。直接克隆出一个对象，就相当于创建了一个新的对象

注意：

​	原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者



## 64.数据库优化

```
一、SQL优化
```

​	1.尽量避免使用SELECT *
​	2.只查询一条语句是使用limit 1
​	3.使用连接查询代替子查询
​	4.尽量使用一些能通过索引查询的字段
二、表结构优化
​	1.尽量使用数字类型字段,提高比对效率
​	2.长度不变且对查询速度要求高的数据可以考虑使用char,否则使用varchar
​	3.表中字段过多时可以适当进行垂直分割,将部分字段移动到另外一张表
​	4.表中数据量过大可以适当进行水平分割.将部分数据移动到另外一张表
三、其他优化
​	1.对查询频率高的字段适当的建立索引,提高效率
​	2.根据表的用途使用合适的数据库引擎
​	3.读写分离

## 65.探析BTree机制

B-Tree是满足下列条件的数据结构：

- d为大于1的一个正整数，称为B-Tree的度。

- h为一个正整数，称为B-Tree的高度。

- 每个非叶子节点由n-1个key和n个指针组成，其中d<=n<=2d。

- 每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。

- 所有叶节点具有相同的深度，等于树高h。

- key和指针互相间隔，节点两端是指针。

- 一个节点中的key从左到右非递减排列。

- 所有节点组成树结构。

- 每个指针要么为null，要么指向另外一个节点。

- 如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于v(key1)v(key1)，其中v(key1)v(key1)为node的第一个key的值。

- 如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于v(keym)v(keym)，其中v(keym)v(keym)为node的最后一个key的值。

- 如果某个指针在节点node的左右相邻key分别是keyikeyi和keyi+1keyi+1且不为null，则其指向节点的所有key小于v(keyi+1)v(keyi+1)且大于v(keyi)v(keyi)。

  ![BTree树结构](D:\BaiduYunDownload\面试题信息\面试题中的图片\BTree树结构.png)

## 66.执行计划深入分析【需实际操作】

一、执行计划能告诉我们什么？

- SQL如何使用索引
- 联接查询的执行顺序
- 查询扫描的数据函数

二、执行计划中的内容

**1. ID列**

- ID列中的如果数据为一组数字，表示执行SELECT语句的顺序；如果为NULL，则说明这一行数据是由另外两个SQL语句进行 UNION操作后产生的结果集
- ID值相同时，说明SQL执行顺序是按照显示的从上至下执行的
- ID值不同时，ID值越大代表优先级越高，则越先被执行

**2. SELECT_TYPE列**



| 值                 | 含义                                                        |
| :----------------- | :---------------------------------------------------------- |
| SIMPLE             | 不包含子查询或是UNION操作的查询                             |
| PRIMARY            | 查询中如果包含任何子查询，那么最外层的查询则被标记为PRIMARY |
| SUBQUERY           | SELECT 列表中的子查询                                       |
| DEPENDENT SUBQUERY | 依赖外部结果的子查询                                        |
| UNION              | Union操作的第二个或是之后的查询的值为union                  |
| DEPENDENT UNION    | 当UNION作为子查询时，第二或是第二个后的查询的select_type值  |
| UNION RESULT       | UNION产生的结果集                                           |
| DERIVED            | 出现在FROM子句中的子查询                                    |



**3. TABLE列**

包含以下几种结果：

> 输出去数据行所在表的名称，如果表取了别名，则显示的是别名
> <union M,N>： 由ID为M,N查询union产生的结果集
> <derived N>/<subquery N> ：由ID为N的查询产生的结果

**4. PARTITIONS列:**

> 查询匹配的记录来自哪一个分区
> 对于分区表，显示查询的分区ID
> 对于非分区表，显示为NULL

**5. TYPE列**

按性能从高至低排列如下：

| 值          | 含义                                                         |
| :---------- | :----------------------------------------------------------- |
| system      | 这是const联接类型的一个特例，当查询的表只有一行时使用        |
| const       | 表中有且只有一个匹配的行时使用，如对主键或是唯一索引的查询，这是效率最高的联接方式 |
| eq_ref      | 唯一索引或主键索引查询，对应每个索引键，表中只有一条记录与之匹配 |
| ref         | 非唯一索引查找，返回匹配某个单独值的所有行                   |
| ref_or_null | 类似于ref类型的查询，但是附加了对NULL值列的查询              |
| index_merge | 该联接类型表示使用了索引合并优化方法                         |
| range       | 索引范围扫描，常见于between、>、<这样的查询条件              |
| index       | FULL index Scan 全索引扫描，同ALL的区别是，遍历的是索引树    |
| ALL         | FULL TABLE Scan 全表扫描，这是效率最差的联接方式             |



**6. Extra列**

包含MySQL如何执行查询的附加信息

| 值                           | 含义                                                         |
| :--------------------------- | :----------------------------------------------------------- |
| Distinct                     | 优化distinct操作，在找到第一个匹配的元素后即停止查找         |
| Not exists                   | 使用not exists来优化查询                                     |
| Using filesort               | 使用额外操作进行排序，通常会出现在order by或group by查询中   |
| Using index                  | 使用了覆盖索引进行查询                                       |
| Using temporary              | MySQL需要使用临时表来处理查询，常见于排序，子查询，和分组查询 |
| Using where                  | 需要在MySQL服务器层使用WHERE条件来过滤数据                   |
| select tables optimized away | 直接通过索引来获得数据，不用访问表，这种情况通常效率是最高的 |

**7. POSSIBLE_KEYS列**

指出MySQL能使用哪些索引来优化查询

查询列所涉及到的列上的索引都会被列出，但不一定会被使用

**8. KEY列**

查询优化器优化查询实际所使用的索引

如果表中没有可用的索引，则显示为NULL

如果查询使用了覆盖索引，则该索引仅出现在Key列中

**9. KEY_LEN列**

显示MySQL索引所使用的字节数，在联合索引中如果有3列，假如3列字段总长度为100个字节，Key_len显示的可能会小于100字节，比如30字节，这就说明在查询过程中没有使用到联合索引的所有列，只是利用到了前面的一列或2列

- 表示索引字段的最大可能长度
- Key_len的长度由字段定义计算而来，并非数据的实际长度

**10. Ref列**

表示当前表在利用Key列记录中的索引进行查询时所用到的列或常量

**11. rows列**

- 表示MySQL通过索引的统计信息，估算出来的所需读取的行数（关联查询时，显示的是每次嵌套查询时所需要的行数）
- Rows值的大小是个统计抽样结果，并不十分准确

**12. Filtered列**

- 表示返回结果的行数占需读取行数的百分比
- Filtered列的值越大越好（值越大，表明实际读取的行数与所需要返回的行数越接近）
- Filtered列的值依赖统计信息，所以同样也不是十分准确，只是一个参考值

**三. 执行计划的限制**

- 无法展示存储过程，触发器，UDF对查询的影响
- 无法使用EXPLAIN对存储过程进行分析
- 早期版本的MySQL只支持对SELECT语句进行分析

#### 重点：

​	使用explain查看sql执行计划后，我们主要先看下【type】属性，表示连接的类型，如果是ALL这种那就需要优化了，

​	再看下possible_key属性，表示可以使用的索引，如果没有则为null，key属性表示mysql实际决定使用的索引，如果没有选择索引，键是null，

​	rows 表示mysql认为它执行查询时必须检查的行数，行数越多效率越低。

## 67.mysql索引优化【使索引生效】

--索引类型

 		主键索引，唯一索引，组合索引，普通索引

--什么是索引

​		 数据库索引是数据库管理系统中的一个排序的数据结构，以协助快速查询，更新数据库表中数据，索引的实现通常使用B树(B-tree)以及其变种B+tree（一些高效率的算法）

--使用索引时有些不生效的情况

 1、使用like关键字模糊查询时，% 放在前面索引不起作用，只有“%”不在第一个位置，索引才会生效（like '%文'--索引不起作用）【like关键字】

 2、使用联合索引时，只有查询条件中使用了这些字段中的第一个字段，索引才会生效【联合索引，必须用到联合索引第一个才会生效】

 3、使用OR关键字的查询，查询语句的查询条件中只有OR关键字，且OR前后的两个条件中的列都是索引时，索引才会生效，否则索引不生效。【OR关键字】

 4、尽量避免在where子句中使用!=或<>操作符，NOT IN和<>操作都不会使用索引将进行全表扫描。NOT IN可以NOT EXISTS代替，id<>3则可使用id>3 or id<3来代替；【NOT IN 会导致全表扫描】

 5、对查询进行优化，应尽量避免全表扫描，首先应考虑在where以及order by涉及的列上建立索引。

 6、应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：【索引字段不要使用表达式】

  　　select id from t where num/2=100 
  　　应改为: 
  　　select id from t where num=100*2 
 7、尽量避免在where子句中对字段进行函数操作,将导致引擎放弃使用索引而进行全表扫描。【mysql内部函数导致索引失效】

 8、不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。

 9、并不是所有的索引对查询都有效，sql是根据表中的数据来进行查询优化的，当索引列有大量数据重复时，sql查询不会去利用索引，如一表中有字段【表中数据重复率过高，也会导致索引失效】
　　sex，male,female几乎个一半，那么即使在sex上建立了索引也对查询效率起不了作用。

 10、索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，【索引并不是越多越好，】

 　　因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，
 　　若太多则应考虑一些不常使用到的列上建的索引是否有 必要。

 11、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。【能用整数，千万不要用字符串型】

 　　这是因为引擎在处理查询和连接时会 逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。

 12、mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。

　　 因此数据库默认排序可以符合要求的情况下不要使用排序操作，尽量不要包含多个列的排序，如果需要最好给这些列建复合索引。

 13、order by 索引 ，不起作用的问题（除了主键索引之外）：【where中用到的索引，在order by时，用其中用到的索引，才能使索引生效】

  　　1、 如果select 只查询索引字段，order by 索引字段会用到索引，要不然就是全表排列；

 　　 2、如果有where 条件，比如where vtype=1 order by vtype asc . 这样order by 也会用到索引！

## 68.慢查询分析与SQL优化

**慢查询** 

**默认情况下，MySQL数据库并不启动慢查询日志**

**slow_query_log** ：是否开启慢查询日志，1表示开启，0表示关闭。

使用**set global slow_query_log=1**开启了慢查询日志**只对当前数据库生效，如果MySQL重启后则会失效。如果要永久生效，就必须修改配置文件。**

慢查询优化基本步骤：

0.先运行看看是否真的很慢，注意设置SQL_NO_CACHE
1.where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高
2.explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）
3.order by limit 形式的sql语句让排序的表优先查
4.了解业务方使用场景
5.加索引时参照建索引的几大原则
6.观察结果，不符合预期继续从0分析

## 69.redis的（value）五种数据结构

​	1.String字符串类型：java中相当于String

​	2.Hash哈希类型：java中相当于HashMap

​	3.List列表类型：java中相当于LinkedList

​	4.Set集合类型：java中相当于HashSet

​	5.SortedSet有序集合类型

## 70，缓存雪崩和缓存穿透、缓存击穿

缓存穿透：缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id 为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据 库压力过大。【有人恶意而为】

缓存击穿：缓存击穿是指缓存中没有但数据库中有的数据。这时由于并发用户特别多，同时读 缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压 力。【一条数据过期，同一条数据，很多人同时访问数据库】

缓存雪崩：缓存雪崩是指缓存数据大批量到过期时间，而查询数据量巨大，引起数据库压力过 大甚至down机。【很多条不同的数据过期，很多人同时访问不同的数据，造成这些数据同时查询数据库】

​	缓存击穿和缓存雪崩的不同：

​		缓存击穿指并发查同一条数据，缓存雪崩是不同 数据都过期了，很多数据都查不到从而查数据库。 

## 71.redis哨兵模式：

​	哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是**哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。**

这里的哨兵有两个作用：

- 通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。
- 当哨兵监测到master宕机，会自动将slave切换成master，然后通过**发布订阅模式**通知其他的从服务器，修改配置文件，让它们切换主机。

## 72.mongodb

#### 1.MongoDB 的概念

​		MongoDB 是一个跨平台的，面向文档的数据库，是当前 NoSQL 数据库产品中最热 门.

​		MongoDB适合什么数据：数据量较大，且价值较低的数据（因为mongodb可能会造成数据丢失）

#### 2.MongoDB体系结构

​		MongoDB 的逻辑结构是一种层次结构。主要由： 文档(document)、集合(collection)、数据库(database)这三部分组成的。逻辑结构是面 向用户的，用户使用 MongoDB 开发应用程序使用的就是逻辑结构。 

​	（1）MongoDB 的文档（document），相当于关系数据库中的一行记录。 

​	（2）多个文档组成一个集合（collection），相当于关系数据库的表。 

​	（3）多个集合（collection），逻辑上组织在一起，就是数据库（database）。 

​	（4）一个 MongoDB 实例支持多个数据库（database）。 

![mongodb数据库结构](D:\BaiduYunDownload\面试题信息\面试题中的图片\mongodb数据库结构.png)

#### 3.MongoDB的数据类型

基本数据类型 

​	null：用于表示空值或者不存在的字段，{“x”:null} 

​	布尔型：布尔类型有两个值true和false，{“x”:true} 

​	数值：shell默认使用64为浮点型数值。{“x”：3.14}或{“x”：3}。对于整型值，可以使用 NumberInt（4字节符号整数）或NumberLong（8字节符号整数）， {“x”:NumberInt(“3”)}{“x”:NumberLong(“3”)} 

​	字符串：UTF-8字符串都可以表示为字符串类型的数据，{“x”：“呵呵”} 

​	日期：日期被存储为自新纪元依赖经过的毫秒数，不存储时区，{“x”:new Date()} 

​	正则表达式：查询时，使用正则表达式作为限定条件，语法与JavaScript的正则表达式相 同，{“x”:/[abc]/} 

​	数组：数据列表或数据集可以表示为数组，{“x”： [“a“，“b”,”c”]} 

​	内嵌文档：文档可以嵌套其他文档，被嵌套的文档作为值来处理，{“x”:{“y”:3 }} 

​	对象Id：对象id是一个12字节的字符串，是文档的唯一标识，{“x”: objectId() } 

​	二进制数据：二进制数据是一个任意字节的字符串。它不能直接在shell中使用。如果要 将非utf-字符保存到数据库中，二进制数据是唯一的方式。 

## 73.**RabbitMQ**

#### 1.RabbitMQ的概念

​	RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。（高级消息队列协议）

#### 2.RabbitMQ的特点

1.可靠性（Reliability） 

​	RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。 

2.灵活的路由（Flexible Routing） 

​	在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个 Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。 

3.消息集群（Clustering） 

​	多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。 

4.高可用（Highly Available Queues） 

​	队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。 

5.多种协议（Multi-protocol） 

​	RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。 

6.多语言客户端（Many Clients） 

​	RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。 

7.管理界面（Management UI） 

​	RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方 面。

8.跟踪机制（Tracing） 

​	如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。 

9.插件机制（Plugin System） 

​	RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。 

#### 3,.RabbitMQ主要概念

**RabbitMQ Server**： 

​		也叫broker server，它是一种传输服务。 他的角色就是维护一条 从Producer到Consumer的路线，保证数据能够按照指定的方式进行传输。 

**Producer**：

​		 消息生产者。消息生产者连接RabbitMQ服 务器然后将消息投递到Exchange。 

**Consumer**：

​		消息消费者。消息消费者订阅队列， RabbitMQ将Queue中的消息发送到消息消费者。 

**Exchange**：

​		生产者将消息发送到Exchange（交换器），由Exchange将消息路由到一个 或多个Queue中（或者丢弃）。Exchange并不存储消息。RabbitMQ中的Exchange有 direct、fanout、topic、headers四种类型，每种类型对应不同的路由规则。 

**Queue**：（队列）

​		是RabbitMQ的内部对象，用于存储消息。消息消费者就是通过订阅 队列来获取消息的，RabbitMQ中的消息都只能存储在Queue中，生产者生产消息并最终 投递到Queue中，消费者可以从Queue中获取消息并消费。多个消费者可以订阅同一个 Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者 都收到所有的消息并处理。 

**RoutingKey**：

​		生产者在将消息发送给Exchange的时候，一般会指定一个routing key， 来指定这个消息的路由规则，而这个routing key需要与Exchange Type及binding key联 合使用才能最终生效。在Exchange Type与binding key固定的情况下（在正常使用时一 般这些内容都是固定配置好的），我们的生产者就可以在发送消息给Exchange时，通过 指定routing key来决定消息流向哪里。RabbitMQ为routing key设定的长度限制为255 bytes。

#### 4.RabbitMQ的模式

​	1.直接模式（**Direct**） ：直接发送给队列

​	2.分列模式（**Fanout**）：发送消息给交换器，然后交换器把消息分裂给多个队列

​	3.主题模式（**Topic**） ：发送消息时，指定交换器和RoutingKey规则，该交换器会把消息发送到，匹配RoutingKey的队列上

#### 5.延迟队列：

​		消息的**TTL**（**Time To Live**）：消息的存活时间，过了存活时间后，就会进入死信路由器

​		死信交换器 **Dead Letter Exchanges** 

​			一个消息在满足如下条件下，会进死信路由，记住这里是路由而不是队列，一个路由可 以对应很多队列。 

​				（1） 一个消息被Consumer拒收了，并且reject方法的参数里requeue是false。也就是 说不会被再次放在队列里，被其他消费者使用。 

​				（2）上面的消息的**TTL**到了，消息过期了。 

​				（3）队列的长度限制满了。排在前面的消息会被丢弃或者扔到死信路由上。 

​			Dead Letter Exchange其实就是一种普通的exchange，和创建其他exchange没有两 样。只是在某一个设置Dead Letter Exchange的队列中有消息过期了，会自动触发消息 的转发，发送到Dead Letter Exchange中去。 

#### 6.RabbitMQ的应用场景（四个场景 ）

​	异步处理，

​	应用解耦，

​	流量削锋

​	消息通讯

## 74.springcloud

#### 1.springcloud的概念

​	Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简 化了分布式系统基础设施的开发

#### 2.springcloud的主要框架

​	服务发现——Netflix Eureka （注册中心）

​	服务调用——Netflix Feign  （实现微服务之间的调用）

​	熔断器——Netflix Hystrix    （避免服务的雪崩效应）

​	服务网关——Netflix Zuul     （（1）微服务工程统一入口，方便前端调用 （2）集中处理权限问题 ）：【为微服务搭载集群提供了帮助】

​	分布式配置——Spring Cloud Config   （服务配置文件统一管理和修改，方便后期维护 ）

​	消息总线 —— Spring Cloud Bus    （不重启微服务的情况下，更新配置文件，让其立刻生效）

服务雪崩效应：

​	在微服务架构中通常会有多个服务层调用，基础服务的故障可能会导致级联故障， 进而造成整个系统不可用的情况，这种现象被称为服务雪崩效应

## 75分布式事务解决方案

#### 1.CAP定理：

​		Consistency 一致性

​		Availability   可用性

​		Partition tolerance  分区容错

​		它们的第一个字母分别是 C、A、P。Eric Brewer 说，这三个指标不可能同时做到。这个 结论就叫做 CAP 定理。 

​		分区容错是不可避免的，所以A和C不能同时满足

#### 2.BASE理论

​		BASE：全称：Basically Available(基本可用)，Soft state（软状态）,和 Eventually consistent（最终一致性）三个短语的缩写，

​	Basically Available(**基本可用**)：

什么是基本可用呢？假设系统，出现了不可预知的故障，但还是能用，相比较正常的系 统而言： 

1. 响应时间上的损失：正常情况下的搜索引擎 0.5 秒即返回给用户结果，而基本可用的 搜索引擎可以在 1 秒作用返回结果。 
2. 功能上的损失：在一个电商网站上，正常情况下，用户可以顺利完成每一笔订单，但 是到了大促期间，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级 页面。 

**Soft state**（软状态） ：

​	什么是软状态呢？相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种 “硬状态”。 软状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用 性，即允许系统在多个不同节点的数据副本存在数据延时。 

**Eventually consistent**（最终一致性） 

​	系统能够保证在没有其他新的更新操作的情况下，数据最终一定能够达到一致的状态， 因此所有客户端对系统的数据访问最终都能够获取到最新的值。 



#### 3.分布式事务解决方案：

​		1.基于**XA**协议的两阶段提交

​		2.**TCC**补偿机制：（俗称三阶段提交）

​		3.消息最终一致性（最常用）

​			基本思路就是： 

​				消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一 个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消 费方。如果消息发送失败，会进行重试发送。 

​				消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成 功，表明已经处理成功了，如果处理失败，那么就会重试执行。如果是业务上面的失 败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。 

​				生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一 遍。如果有靠谱的自动对账补账逻辑，这种方案还是非常实用的。 

​				优点： 一种非常经典的实现，避免了分布式事务，实现了最终一致性。 

​				缺点： 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。

#### 4.具体实现思路（重点）：

​		1.在创建订单时，先减少库存和增加销量

​		2.在生成订单和订单明细时，try。。。catch一下，如果发生异常就在catch后面是有rabbitMQ发送消息，表示订单创建失败，然后让库存和销量回滚

## 76.Eureka与Zookeeper的区别

CAP理论中：

```
  Zookeeper保证的是CP
 	 当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。
  Eureka则是AP。
```

```
 	Eureka看明白了这一点，因此在设计时就优先保证可用性。Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务
```

## 77.filter和interceptor的区别

​	filter：

​		1.适用范围：filter是servlrt中的一部分，所以在所有的java web项目中都能使用

​		2.拦截范围：如果在web.xml中配置了/*这个拦截路径后，就能对所有的静态资源和动态资源进行拦截，同时不会让该资源进入到serlvet中

​	interceptor：

​		1.适用范围：这是spring-mvc框架中的一部分，所以只能在spring-mvc框架中使用

​		2.拦截范围：只能拦截动态资源，不能拦截静态资源，而且拦截是作用在servlet上的，所以请求会访问到servlet，而且拦截器只对我们所写的contrllor方法进行拦截

## 78.cglib和jdk动态代理的区别

​	jdk代理： 基于接口的动态代理技术（代理类和目标类实现相同的接口），目标类必须是实现类接口

​		开发步骤：1.创建目标对象。2.创建代理对象，3.使用代理对象调用方法

​	cglib代理：基于父类的动态代理技术（代理类可以当做是目标类的子类），目标类可以没得实现的接口

​		开发步骤：1.创建目标类，2.创建增强器，3.通过增强类设置父类。4.拖过增强类设置回调，5.通过增强类创建代理对象。6.使用代理对象调用方法

## 79.spring七大 模块的相关描述

​	七大模块，如下：

​	1.Spring Core： Core封装包是框架的最基础部分，提供IOC和依赖注入特性。这里的基础概念是BeanFactory，它提供对Factory模式的经典实现来消除对程序性单例模式的需要，并真正地允许你从程序逻辑中分离出依赖关系和配置。

​	2.Spring Context: 构建于[Core](http://www.mianwww.com/html/2014/03/19750.html#beans-introduction)封装包基础上的 [Context](http://blog.chinaunix.net/u/9295/ch03s08.html)封装包，提供了一种框架式的对象访问方法，有些象JNDI注册器。Context封装包的特性得自于Beans封装包，并添加了对国际化（I18N）的支持（例如资源绑定），事件传播，资源装载的方式和Context的透明创建，比如说通过Servlet容器。

​	3．Spring DAO:  [DAO](http://www.mianwww.com/html/2014/03/19750.html#dao-introduction) (Data Access Object)提供了JDBC的抽象层，它可消除冗长的JDBC编码和解析数据库厂商特有的错误代码。 并且，JDBC封装包还提供了一种比编程性更好的声明性事务管理方法，不仅仅是实现了特定接口，而且对所有的POJOs（plain old Java objects）都适用。

​	4.Spring ORM: [ORM](http://www.mianwww.com/html/2014/03/19750.html#orm-introduction) 封装包提供了常用的“对象/关系”映射APIs的集成层。 其中包括[JPA](http://blog.chinaunix.net/u/9295/ch12s07.html)、[JDO](http://blog.chinaunix.net/u/9295/ch12s03.html)、[Hibernate](http://blog.chinaunix.net/u/9295/ch12s02.html) 和 [iBatis](http://blog.chinaunix.net/u/9295/ch12s06.html) 。利用ORM封装包，可以混合使用所有Spring提供的特性进行“对象/关系”映射，如前边提到的简单声明性事务管理。

​	5.Spring AOP: Spring的 [AOP](http://www.mianwww.com/html/2014/03/19750.html#aop-introduction) 封装包提供了符合AOP Alliance规范的面向切面的编程实现，让你可以定义，例如方法拦截器（method-interceptors）和切点（pointcuts），从逻辑上讲，从而减弱代码的功能耦合，清晰的被分离开。而且，利用source-level的元数据功能，还可以将各种行为信息合并到你的代码中。

​	6.Spring Web: Spring中的 Web 包提供了基础的针对Web开发的集成特性，例如多方文件上传，利用Servlet listeners进行IOC容器初始化和针对Web的ApplicationContext。当与WebWork或Struts一起使用Spring时，这个包使Spring可与其他框架结合。

​	7.Spring Web MVC: Spring中的[MVC](http://www.mianwww.com/html/2014/03/19750.html#mvc-introduction)封装包提供了Web应用的Model-View-Controller（MVC）实现。Spring的MVC框架并不是仅仅提供一种传统的实现，它提供了一种清晰的分离模型，在领域模型代码和Web Form之间。并且，还可以借助Spring框架的其他特性。

## 80.@transactional注解在什么情况下会失效，为什么

1.检查方法是不是public的： @Transactional注解只对代理类时的public方法有效，被protected、private、package-visible修饰的方法使用@Transactional注解无效，对这类方法使用事务注解，推荐使用AspectJ进行事务管理

2.异常类型是不是unchecked异常

如果想让checked异常也回滚，在注解上面写明异常类型即可:

@Transactional(rollbackFor=Exception.class)

类似还有norollbackFor，自定义不回滚的异常

3.数据库引擎要支持事务，如果是Mysql，注意表要使用支持事务的引擎，比如innaodb，如果是myisam，事务是不起作用的

4.是否开启了对注解的解析:

```
<tx:annotation-driven transaction-manager="transactionManager" proxy-target-class="true"/>
```

5.spring是否扫描到你使用注解事务的这个类所在的包：

```
<context:component-scan base-package="com.xxx.xxx" ></context:component-scan>
```

6.检查是不是同一个类中的方法调用(如a方法调用同一个类中的b方法)

7.异常是不是被catch住了

## 81.spring的Bean的几种作用域

- singleton：单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例
- prototype：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例
- request：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效
- session：对于每次HTTP Session，使用session定义的Bean豆浆产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效
- globalsession：每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。同样只有在Web应用中使用Spring时，该作用域才有效

## 82.Ajax原理

**Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发送异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。**

## 83.jsp的九大内置对象

```
           变量名					   真实类型						作用
        1. pageContext				PageContext					当前页面共享数据，还可以获取其他八个内置对象
        2. request					HttpServletRequest			一次请求访问的多个资源(转发)
        3. session					HttpSession					一次会话的多个请求间
        4. application				ServletContext				所有用户间共享数据
        5. response					HttpServletResponse			响应对象
        6. page						Object						当前页面(Servlet)的对象  this
        7. out						JspWriter					输出对象，数据输出到页面上
        8. config					ServletConfig				Servlet的配置对象
        9. exception				Throwable					异常对象
```

## 84.cookie和session的区别

​	cookie：

```utf-8
		1. Cookie 是将数据存储在浏览器，所以不太安全
		2. 浏览器对单个 Cookie 的大小和一个网站存储的持久化 Cookie 的数量有限制
		3. cookie不是一个域对象
```

​	session：

```
		1. Session 是将数据保存在服务器端，相对更安全
		2. 存储的数据没有大小限制
			 注意：虽然没有大小限制，但是不要向 Session 中存储过多数据，因为数据是存储在服务器内存中的，对服务器内存消耗比较大
		3. Session 是一个域对象
			 Session 的域范围是一次会话(包含多次请求)，所以无论请求转发还是请求重定向都可以使用 Session 来共享数据
```

## 85.js几种选择器

​		1.基本选择器：1.ID选择器，2.class选择器，3.元素选择器，4，并集选择器

​		2.层级选择器：1.后代选择器，2.子类选择器

​		3.属性选择器：1.属性名选择器，2.属性值选择器，3.属性值以什么开始，4.属性值以什么结束，5.属性值包含什么，6.标题选择器，7.属性值不包括什么，8.属性名的并列选择器

​		4.基本过滤选择器：1.first，2.last，3.大于gt，4.小于lt，5.等于eq，6.奇数odd，7.偶数even，8.not（选择器）

​		5.表单选择器和表单对象属性选择器：1.input所有表单项，2.enable可用，3.disable不可用，4.checked复选框选中，5.selected下拉列表选中选中

## 86.spring的执行流程

web容器启动时，下面为spring加载执行步骤：

​	1.执行web.xml中的ContextLoaderListener监听器
​	2.初始化ContextLoaderListener中的contextInitialized方法 

​	3.contextInitialized方法中调用父类（ContextLoader）的initWebApplicationContext方法 

​	4.initWebApplicationContext方法中执行了三个任务 
​		4.1创建WebApplicationContext容器 

​		4.2加载context-param中配置的spring配置文件

​		4.3初始化配置文件中及创建配置文件中的bean 

## 87.springmvc的执行流程

- ### 一个请求匹配前端控制器 DispatcherServlet 的请求映射路径(在 web.xml中指定), WEB 容器将该请求转交给 DispatcherServlet 处理

- ### DispatcherServlet 接收到请求后, 将根据 请求信息 交给 处理器映射器 （HandlerMapping）

- ### HandlerMapping 根据用户的url请求 查找匹配该url的 Handler，并返回一个执行链 

- ### DispatcherServlet 再请求 处理器适配器(HandlerAdapter) 调用相应的 Handler 进行处理并返回 ModelAndView 给 DispatcherServlet

- ### DispatcherServlet 将 ModelAndView 请求 ViewReslover（视图解析器）解析，返回具体 View

- ### DispatcherServlet 对 View 进行渲染视图（即将模型数据填充至视图中）

- ### DispatcherServlet 将页面响应给用户

## 88.数据库引擎innodb与myisam区别

![数据库引擎的区别](D:\BaiduYunDownload\面试题信息\面试题中的图片\数据库引擎的区别.png)

## 89.MyBatis框架的优缺点及其适用场合

#### 一、MyBatis框架的优点：

1. 与JDBC相比，减少了50%以上的代码量。

2. MyBatis是最简单的持久化框架，小巧并且简单易学。

3. MyBatis相当灵活，不会对应用程序或者数据库的现有设计强加任何影响，SQL写在XML里，从程序代码中彻底分离，降低耦合度，便于统一管理和优化，并可重用。

4. 提供XML标签，支持编写动态SQL语句。

5. 提供映射标签，支持对象与数据库的ORM字段关系映射。



#### 二、MyBatis框架的缺点：

1. SQL语句的编写工作量较大，尤其是字段多、关联表多时，更是如此，对开发人员编写SQL语句的功底有一定要求。

2. SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。



#### 三、MyBatis框架适用场合：

MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案。

对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis将是不错的选择。
